<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <link rel="alternate" type="application/atom+xml" title="Srikanth Sastry" href="/feed.xml">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      Srikanth Sastry &middot; A Techie in Boston
    
  </title>

  
  <link rel="canonical" href="//srikanth.sastry.name/page4/">
  

  <link rel="stylesheet" href="//srikanth.sastry.name/public/css/poole.css">
  <link rel="stylesheet" href="//srikanth.sastry.name/public/css/syntax.css">
  <link rel="stylesheet" href="//srikanth.sastry.name/public/css/lanyon.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400">

  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="//srikanth.sastry.name/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="//srikanth.sastry.name/public/favicon.ico">

  <link rel="alternate" type="application/rss+xml" title="RSS" href="//srikanth.sastry.name/atom.xml">

  
</head>


  <body class="sidebar-overlay">

    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <p>A personal website</p>
  </div>

  <nav class="sidebar-nav">
    <a class="sidebar-nav-item active" href="//srikanth.sastry.name/">Home</a>

    

    
    
      
        
      
    
      
        
      
    
      
        
          <a class="sidebar-nav-item" href="//srikanth.sastry.name/about/">About</a>
        
      
    
      
        
          <a class="sidebar-nav-item" href="//srikanth.sastry.name/archives/">Archives</a>
        
      
    
      
    
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
          <a class="sidebar-nav-item" href="//srikanth.sastry.name/publications/">Publications</a>
        
      
    
      
        
          <a class="sidebar-nav-item" href="//srikanth.sastry.name/touchstone-radio-episodes/">Touchstone Radio Episodes</a>
        
      
    
    <!-- <a class="sidebar-nav-item" href="/archive/v1.1.0.zip">Download</a>
    <a class="sidebar-nav-item" href="">GitHub project</a>
    <span class="sidebar-nav-item">Currently v1.1.0</span> -->
  </nav>
  <div class="sidebar-item">
  <p>
  <a class="navbar-item" href="/feed.xml" target="_blank">Feed</a>
  </p>
  </div>
  <div class="sidebar-item">
    <p>
      &copy; 2022. All rights reserved.
    </p>
  </div>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="/" title="Home">Srikanth Sastry</a>
            <small>A Techie in Boston</small>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="posts">
  
  <div class="post">
    <h1 class="post-title">
      <a href="//srikanth.sastry.name/when-should-you-build-for-survival/">
        When should you build for survival?
      </a>
    </h1>

    <span class="post-date">21 Aug 2019</span>

    <!-- wp:image {"align":"center","id":463} -->
<div class="wp-block-image"><figure class="aligncenter"><img src="https://srikanth.sastry.name/wp-content/uploads/2019/08/Are-You-Succeeding-Blog-thegem-blog-default-1024x512.jpg" alt="" class="wp-image-463" /><!-- <figcaption>source: http://beaconbusinessmarketing.com/success-vs-survival/</figcaption> --> </figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Previously, I wrote about <a href="/are-you-building-for-survival-or-excellence/">building for survival vs. success</a> building for survival vs. success. Briefly, when building for survival, your only goal to get the product working for the specific usecase, and in contrast, when building for success, you are building to solve a bigger class of problems within the broader context of your solution space. In this post, I will talk about when you should be build for survival, and when for success.
<!-- /wp:paragraph --></p>

<!-- wp:more -->
<!--more-->
<!-- /wp:more -->

<!-- wp:heading -->
<h2>A Straw Man</h2>
<!-- /wp:heading -->

<!-- wp:image {"align":"center","id":464,"width":349,"height":262} -->
<div class="wp-block-image"><figure class="aligncenter is-resized"><img src="https://srikanth.sastry.name/wp-content/uploads/2019/08/Meet-You-Strawman.jpg" alt="" class="wp-image-464" width="349" height="262" /><!--<figcaption>source: https://prepareforchange.net/wp-content/uploads/2016/06/Meet-You-Strawman.jpg</figcaption>--></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>On the face of it, it seems like an easy answer: "<em>build for survival, when survival is at stake; otherwise, build for success.</em>" But unfortunately, that answer hides a multitude of assumptions, and oversimplifies the real-world within which the software development process operates. So, let's first breakdown the assumptions, and then address the oversimplification.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>The assumptions</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>The first assumption here is the notion that we have a common understanding of what it means to say that a project/product's "survival is at stake". And the second assumption is that building for survival in all such cases will actually help. </p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4>Is your survival at stake?</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p> Let's examine the first assumption: <em>we can agree on what it means for survival to be at stake.</em> Sure, in the extreme cases, we can all agree on this notion (e.g., a startup has a runway of 6 months, and additional funding depends on delivering an alpha in 3 months), but moving past that, things become a lot more subjective. </p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Consider a new project/product incubating within a well established company such as Facebook or Google. Is it's survival ever at stake? How about a project that involves building/dismantling infrastructure with a fixed, slightly aggressive, deadline; would it's survival be at stake? The answers to the above questions are not always obvious, and they can be different depending on who you ask. They can differ depending on where you are in the organizational hierarchy; it can even differ among developers within the team. </p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4>Ok, so your survival is at stake. So should you build for survival?</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Now on to the second assumption: <em>when survival is at stake, building for survival is actually the right thing to do</em>. Again, there are some obvious cases where this is the right call. What about a case where the survival of your medical diagnostic software is at stake; would building for survival actually be the right thing (given that 'break things' is a corollary of 'move fast')?  How about when you realize that you were a little too optimistic about what the product could accomplish with the limited resources you have; is building for survival still the right thing (ask Microsoft about Windows Vista)?</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The oversimplification made here is that we only ever have two choices: survival, or success. This is almost never the case. You can almost always negotiate. You can negotiate on deadlines, on scope, on resources, on expectations, and on outcomes. Without taking all of the above into account, the discussion of survival vs success is meaningless. </p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>So, when should you build for survival vs success?</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>While you have to evaluate every situation independently and holistically to determine which approach is the right one to take, here are some rule-of-thumb symptoms that suggest that you should be building for survival.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>You are resource constrained, and failure is an option</h3>
<!-- /wp:heading -->

<!-- wp:image {"align":"center","id":465,"width":234,"height":156} -->
<div class="wp-block-image"><figure class="aligncenter is-resized"><img src="https://srikanth.sastry.name/wp-content/uploads/2019/08/product-resource-graphic01.png" alt="" class="wp-image-465" width="234" height="156" /><!-- <figcaption>source: https://www.triskellsoftware.com/wp-content/uploads/2016/01/product-resource-graphic01.png</figcaption> --></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>When you are resource constrained, then there is a good chance that you cannot afford the time/effort/resources that a principled approach to software development demands. Recall, that in such a case, I talked about renegotiating the original parameters and expectations. However, they are not always negotiable. (<em>E.g.</em>, you might have only a few months' of runway, and your investor might not be willing to fund you in case of milestone slippage.) In such cases, failure becomes a better option than renegotiation (almost vacuously). Here, building of survival makes sense.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>Your environment is highly uncertain</h3>
<!-- /wp:heading -->

<!-- wp:image {"align":"center","id":466,"width":349,"height":349} -->
<div class="wp-block-image"><figure class="aligncenter is-resized"><img src="https://srikanth.sastry.name/wp-content/uploads/2019/08/Uncertainty-Reigns-Supreme-for-Fixed-Income-Investors-in-2015-e1505506674364.png" alt="" class="wp-image-466" width="349" height="349" /> <!-- <figcaption>source: https://blogs.cfainstitute.org/investor/2015/09/08/uncertainty-reigns-supreme-for-fixed-income-investors-in-2015/</figcaption> --> </figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>High uncertainty is often a good trigger to build for survival. High uncertainty often requires you to 'fail fast'. If you are working on experimental technology, or on nascent problem spaces, there really isn't much to grok without actually building something and test things out. In other cases, it might not be possible to know if you are solving the right problem; this happens often when your customers tend to "know it when they see it".</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>Your survival is more important than stakeholders' risks</h3>
<!-- /wp:heading -->

<!-- wp:image {"align":"center","id":467,"width":376,"height":349} -->
<div class="wp-block-image"><figure class="aligncenter is-resized"><img src="https://srikanth.sastry.name/wp-content/uploads/2019/08/stakeholders.png" alt="" class="wp-image-467" width="376" height="349" /> <!-- <figcaption>source: https://corporatefinanceinstitute.com/resources/knowledge/finance/stakeholder/</figcaption> --> </figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>This one is less obvious. It could well be the case that your survival is at stake, you are resource constrained, and there is no negotiating. However, there still are situations when you should not build for survival. One big situation is when the stakeholders' risks trump your survival.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The most egregious example I can think of is in medical technology. If you software you are building is for (say) medical diagnosis, and a wrong diagnosis can mean the difference between life and death of a patient, then you should never, ever, ever build for survival. From here, you can extrapolate to all other situations where your stakeholders' risk outweighs yours.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>You are solving a one-time problem</h3>
<!-- /wp:heading -->

<!-- wp:image {"align":"center","id":468} -->
<div class="wp-block-image"><figure class="aligncenter"><img src="https://srikanth.sastry.name/wp-content/uploads/2019/08/Throw-away-Prototyping-Model.jpg" alt="" class="wp-image-468" /> <!-- <figcaption>source: https://prototypeinfo.com/evolutionary-prototyping-and-throw-away-prototyping/</figcaption>  --> </figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>This one is tricky, because solutions to one-time problems have a nasty tendency of sticking around a lot longer than they should. However, in principle, if you are writing software that is going to be used just once, and then discarded, then you should consider building for survival. However, please ensure that that software will NOT persist past it's primary use. Incidentally, if your work involves building prototypes and proof-of-concept works, then you are almost definitely building for survival.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>There are multiple ways to enforce this: (1) do not put it into version control at all, (2) put the code in a new repo that is nuked on a timer, (3) prevent importing modules from this codebase to anywhere else, <em>etc</em>.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Can you think of any other situations where building for survival is warranted? Let me know in the comments.</p>
<!-- /wp:paragraph -->

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="//srikanth.sastry.name/are-you-building-for-survival-or-excellence/">
        Are you building for Survival or Excellence?
      </a>
    </h1>

    <span class="post-date">15 Aug 2019</span>

    <!-- wp:image {"id":453} -->
<figure class="wp-block-image"><img src="https://srikanth.sastry.name/wp-content/uploads/2019/08/maxresdefault-1024x576.jpg" alt="" class="wp-image-453" /><figcaption>Source: https://www.youtube.com/attribution?v=oW2i6QpnmyY</figcaption></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>In my experience, the approach to building a software artifact often falls into one of two types: <em>building for survival</em>, or <em>building for success</em>.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>When building for survival, your only goal to get the product working for the specific usecase(s) that will save your skin. In contrast, when building for success, you are building to solve more than just the immediate problem; you are building to set up building blocks that is incidentally used to solve the immediate problem, but can also be adapted to solve a larger class of problems within the same context.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>This post is not about when to choose what approach. Instead, it is about what each of the two approaches look like, and what purposes they serve. <a href="https://srikanth.sastry.name/when-should-you-build-for-survival/">A subsequent post will talk about when I think each approach is appropriate.</a></p>
<!-- /wp:paragraph -->

<!-- wp:more -->
<!--more-->
<!-- /wp:more -->

<!-- wp:paragraph -->
<p>In theory, specific circumstances should determine which of these two approaches ought to be used. Unfortunately, all too often, the developer's temperament determines the approach, and this IMHO is a mistake. I have seen consequences of such mistakes last through multiple years and impact the morale of multiple teams and engineers. </p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Building for survival</h2>
<!-- /wp:heading -->

<!-- wp:image {"align":"center","id":454,"width":220,"height":309} -->
<div class="wp-block-image"><figure class="aligncenter is-resized"><img src="https://srikanth.sastry.name/wp-content/uploads/2019/08/6028945055_2271b47a5b_m.jpg" alt="" class="wp-image-454" width="220" height="309" /><figcaption>Source: https://www.flickr.com/photos/bandrews/6028945055</figcaption></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Building for survival often translates to 'being fast', taking shortcuts, and solving for the immediate use case. However, remember that when you do this, your software incurs a debt that will have to be paid eventually. Every incremental functional change you make on top of it incurs interest on the existing debt. Refusal to address it makes it incredibly difficult for your software to evolve and improve. This has a direct impact in your team’s morale. Ask any team that is left supporting ‘legacy’ code, or has some ‘black box’, ‘sacred cow’ modules that no understands, but is business critical. </p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>What does building for survival look like?</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>How do you know you are now in the regime of building for survival? There are many clues to look for. I'll list three.</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>Typically, when building for survival, your deadlines are sacred. Think about everything that you or your company has had to do to meet GDPR deadlines. The odds are that all of that was done in the mode of <em>building for survival</em>.</li><li>The second clue is that you deem it more important that some specific usecase work end-to-end, than that things are done the 'right' way (the discussion of what is a 'right' way is a topic for a whole other discussion). You see this often in early stage startups where they have an alpha customer who has promised to your product/service for some specific purpose, and your next round of funding is contingent upon demonstrating the utility of your product/service with that (isolated) context.</li><li>The third, and perhaps the strongest, clue is that to (the collective) you, the end product is more important than the software development process. If your engineering culture is to 'get things done' by 'hook or crook', then you are most definitely building for survival.</li></ul>
<!-- /wp:list -->

<!-- wp:heading {"level":3} -->
<h3>What does building for survival get you?</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>You survive, period. It gets you to where you want to be, and within a reasonable amount of time, with potentially steep discounting of the future. There really isn't much beyond that to show for.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>What it doesn't give you</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>It is important to realize the trade-off you are making when building for survival, and not be under illusions. </p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>For starts, do not mistake hitting your milestones under this approach to <em>success</em>. Sure, you may have succeeded in getting where you want to be, but that's not the end of the story. </li><li>Presumably, the software you just delivered is not going to be abandoned imminently. So, what you need is a path forward, and that is exactly what this approach will not provide. Building for survival does not necessarily tell you how and where to go next. It shines no light on the landscape of possibilities that could have been unlocked.</li><li>It doesn't tell you what else can your artifact be used for, or it fits into the larger ecosystem. In the pursuit of 'moving fast', the odds are they you have built in so many assumptions into your code that even cognitively extricating the underlying technological innovation from the business logic and the business logic from the use cases becomes challenging.</li></ul>
<!-- /wp:list -->

<!-- wp:heading -->
<h2>Building for Success</h2>
<!-- /wp:heading -->

<!-- wp:image {"align":"center","id":455} -->
<div class="wp-block-image"><figure class="aligncenter"><img src="https://srikanth.sastry.name/wp-content/uploads/2019/08/1ijN1lAVtTBPmh2hCwDWozw.png" alt="" class="wp-image-455" /><figcaption>source: https://medium.com/deliberate-data-science/deliberate-data-science-intro-eac1b1a06568</figcaption></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Building for success is a much more deliberate process that includes grokking the true context of the problem you are solving, and being critical of everything you choose to build. But it is important to be sure that you actually have such a luxury; otherwise, your software will likely become part of the vast graveyard of failed projects, products, and companies.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>What does building for success look like?</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>There are lots of ways building for success is different from building for survival.</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>You deliberate before execution. You ask questions such as: <ul><li>What is the problem we are solving? </li><li>Are we solving the right problem? </li><li>Is our proposal the right way to solve the problem? </li></ul></li><li>You deconstruct the problem to understand the larger context and nature of the sub-problems you are solving. You tease out the incidental nature of how these sub-problems combine versus the essential nature of the overall problem to be solved.</li><li>Your execution is heavily informed by the aforementioned analysis. You apply the deconstruction and analysis to each sub-problem recursively until the actual act of writing the code becomes a rote exercise. The 'magic' and 'innovation' in your execution is really in how you compose such 'simple pieces of code' to solve your non-trivial problem across layers of abstractions (which are translated directly from your deconstructions).</li><li>The code paths within your subsystems and modules are constrained to the supported use cases, but that is the result of intentional plumbing across the data flow. Addition of new use cases and flows is often a matter of easily understandable and incremental changes.</li><li>Your control flow mimics your data flow within the system. (Unless there is a very good reason for it not to be the case.)</li></ul>
<!-- /wp:list -->

<!-- wp:heading {"level":3} -->
<h3>What does building for success give you</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Despite it not being the 'fast' way to build software. There is a lot of be said for Building for Success. </p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>The deliberation process before you build should result in a decent understanding of the context within which you are solving your problem. This often means, your team and the software is now in a much better position to solve more problems faster. Effectively you have expanded your 'pie'.</li><li>Almost always, problems do not occur/manifest in isolation. They are part of a larger landscape of issues, utilities, and benefits. Deconstructing the problem through this lens will help you build a solution that is more likely to have reusable and sustainable components and modules that will lower the incremental effort associated with the evolution of your systems and their adaptation to solve proximate and associated problem.</li><li>A well thought out design allows you to shard your development across multiple developers. This will help in three ways: <ol><li>You can 'move fast' with concurrent execution.</li><li>Each developer can work on multiple workstreams, and is less likely to be completely stuck.</li><li>Your software's <a href="https://en.wikipedia.org/wiki/Bus_factor">bus factor</a> is much improved with more engineers on the code.</li></ol></li><li>You can pivot better and faster because a lot of what you wrote is reusable and reconfigurable. You can <a href="https://srikanth.sastry.name/object-composition-for-service-migration/">migrate from one upstream dependency to another</a> much more smoothly. A good composition-based design allows you to make disruptive changes without actually disrupting :)</li></ul>
<!-- /wp:list -->

<!-- wp:heading {"level":3} -->
<h3>What it doesn't give you</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>You will not have a quick start. You will be a little slower starting from square one. It will take time to start putting together code that actually does something real and concrete.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>You are vulnerable to analysis paralysis. The bar for action is much higher when building for success. It takes a certain type of decisiveness, and ability to <a href="https://en.wikipedia.org/wiki/Disagree_and_commit">disagree and commit</a>, to be able to flourish under this approach.</p>
<!-- /wp:paragraph -->

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="//srikanth.sastry.name/object-composition-for-service-migration/">
        Object Composition for Service Migration
      </a>
    </h1>

    <span class="post-date">24 Jan 2019</span>

    <!-- wp:paragraph -->
<p><a href="https://en.wikipedia.org/wiki/Object_composition">Object Composition</a> is a very powerful and pervasive software design technique. Yet, paradoxically, it is an underutilized design pattern whose lack of usage is the root of many anti-patterns in software development. One that I continue to come across regularly has to do with not using composition to test and migrate a piece of software from one service to another.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Briefly, <em>Object Composition</em> is combining two or more objects to create more complex objects while keeping definitions of the constituent objects unchanged (unlike <a href="https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)">inheritance</a>, which extends these definitions)</p>
<!-- /wp:paragraph -->

<!-- wp:more -->
<!--more-->
<!-- /wp:more -->

<!-- wp:heading -->
<h2>Set Up </h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Say you have an existing backend service that your code currently uses. It has evolved over time to become a chimera that needs replacing, and you have a brand new implementation of that service that can replace your old service. </p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Say, the two client implementations looks something like the following:</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">class OldAndBusted implements ServiceClient {<br />  @override<br />  Response process(Request request) {<br />    // Hacky code.<br />    if (request.type == A) {<br />      // Ugly code.<br />    } else if (request.type == B) {<br />      // Even uglier code.<br />    } else {<br />      // A monstrosity that needs to be killed with fire<br />    }<br />    return response;<br />  }<br />}<br /><br />class NewHotness implements ServiceClient {<br />  @override<br />  Response process(Request request) {<br />    // Best code ever written.<br />    return response;<br />  }<br />}</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>The goal is to migrate your code from using OldAndBusted to NewHotness. There are several ways to do this wrong. So it is easier if I demonstrate a right way to do this using Object Composition.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>A right way</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>There are really four steps to such a migration.</p>
<!-- /wp:paragraph -->

<!-- wp:list {"ordered":true} -->
<ol><li><em>Verify equivalence</em>: Shadow a percentage of your calls to the new service, log mismatches in the response, and fix all such mismatches.</li><li><em>Configure migration</em>: Setup service migration to proceed in phases.</li><li><em>Migrate and clean up</em>: Complete migration and delete the old service.</li></ol>
<!-- /wp:list -->

<!-- wp:heading {"level":3} -->
<h3>Step 1. Verify equivalence</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>The goal here is to ensure that before we start migration, the new service is functionally identical to the old service. We accomplish this through composition of old and new service as sketched out next.</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">class ClientWithShadow implements ServiceClient {<br />  ClientWithShadow(ServiceClient oldAndBusted, <br />                   ServiceClient newHotness) {<br />    this.oldAndBusted = oldAndBusted;<br />    this.newHotness = newHotness;<br />  }<br />  @override<br />  Response process(Request request) {<br />    oldResponse = oldAndBusted.process(request);<br />    if (shouldShadow(request)) {<br />      newResponse = newHotness.process(request);<br />      if (!oldResponse.equals(newResponse)) {<br />        logMismatch(oldResponse, newResponse);<br />      }<br />    }<br />    return newResponse;<br />  }<br /><br /></pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>The pseudocode code above simply delegates calls to the old service, and if shadowing is requires, it additionally delegates to the new service as well and compares the two outputs. It logs any mismatches it sees so that the developer can then take a look at it to ensure that it is addressed.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>You simply replace all calls to OldAndBusted with calls to ClientWithShadow.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>Step 2. Configure migration</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>After you have determined that the two services are indeed functionally alike, we can then prep for migration. Again, object composition helps us set this up cleanly.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Pseudocode for setting up such a migration follows next. Here, I assume that there is a Config object that contains the migration related config.</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">class MigrationClient implements ServiceClient {<br />  MigrationClient(ServiceClient oldAndBusted, <br />                  ServiceClient newHotness,<br />                  Config migrationConfig) {<br />    this.oldAndBusted = oldAndBusted;<br />    this.newHotness = newHotness;<br />    this.migrationConfig = migrationConfig;<br />  }<br />  @override<br />  Response process(Request request) {<br />    if (migrationConfig.useNewService(request)) {<br />     return newHotness.process(request);<br />    }<br />    return oldAndBusted.process(request);<br />  }</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>You simply replace all instances of ClientWithShadow with MigrationClient. Yes, it really is that simple! The migration config has all the info it needs to figure out whether a given request should use the new service or the old service.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>Step 3. Migrate and clean up</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Here, we do the actual migration. We set up the config to slowly start shifting some of the load from the old service to the new one, while monitoring to make sure everything is going well. We can always roll back the migration by editing the config without actually modifying the code, which is a big deal here.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>After migration to the new service a 100%, you can simply replace MigrationClient instances with NewHotness instances, and delete all the old code (OldAndBusted, ClientWithShadow, and MigrationClient). And you are all cleaned up. Profit!</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>So many wrong ways<br /></h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Unfortunately, I have seen this done in way too many wrong ways.</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li> I have seen use of inheritance to extend OldAndBusted to NewHotness, and some hacky switch inside the NewHotness implementation to do shadowing and migration.</li><li>I have seen hacky if-else modification of OldAndBusted that the new if-block implementing NewHotness functionality.</li><li>I have seen developers skip shadowing entirely only to cause major service incidents.</li><li>Many more ways that are not that interesting, except for disaster tourism.</li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>So, object composition is useful, it is powerful, and please use it more!</p>
<!-- /wp:paragraph -->

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="//srikanth.sastry.name/follyfuture-ontimeout-and-a-race-condition/">
        folly:Future, onTimeout(), and a race condition
      </a>
    </h1>

    <span class="post-date">18 Jan 2019</span>

    <!-- wp:image {"id":365,"align":"center","width":338,"height":338} -->
<div class="wp-block-image"><figure class="aligncenter is-resized"><img src="http://srikanth.sastry.name/wp-content/uploads/2019/01/C-programming-in-a-nutshell-Imgur-450x450.png" alt="" class="wp-image-365" width="338" height="338" /></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p><strong>TL;DR.</strong> The inability to cancel threads in C++ can result in bizarre semantics even in seemingly straightforward (and almost) declarative code. folly::Future is an interesting case in point.</p>
<!-- /wp:paragraph -->

<!-- wp:more -->
<!--more-->
<!-- /wp:more -->

<!-- wp:paragraph -->
<p><a href="https://github.com/facebook/folly/blob/master/folly/docs/Futures.md">Folly Futures</a> is an Async C++ framework from Facebook. It has an interesting function <a href="https://github.com/facebook/folly/blob/8757861f41c4b58ac2948ef3dc91aef9cdc8aba0/folly/futures/Future.h#L1545">onTimeout()</a>, which essentially allows to stop waiting on a Future forever. So you would typically use it as follows.</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">provider_.getOperationFuture(Request r)<br />   .then([&amp;](Response response) {<br />     doFoo();  // Accesses variables in the surrounding scope<br />   })<br />   .onTimeout(milliseconds(500), [&amp;]{<br />     doBar();  // Accesses variables in the surrounding scope<br />   })   <br />.get();</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>The semantics that I expected from this piece of code was the following: </p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">if there is no response within 500 milliseconds, then<br />   the future throws a timeout, thus executing  doBar()<br />  else<br />   the future executes the then() block, thus executing doFoo(</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>Importantly, I was expecting exactly one of the two function doFoo() or doBar() to be executed. And it turns out not be true!</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Race Condition</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>It turns out that the Future has a background thread running waiting for the response, and this thread is not cancelled upon timeout because: </p>
<!-- /wp:paragraph -->

<!-- wp:list {"ordered":true} -->
<ol><li>This thread is spawned first, and that in-turn waits on the timeout, and</li><li>C++ does not support canceling threads.</li></ol>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>So, we now have a race condition between the Future's response and timeout, thus potentially causing memory overruns and segfaults. How do you get around this? How do you use folly::Future with the semantics I outlined above? </p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Remedies</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>I found two possible ways for this.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>Swap onTimeout() and then()</h3>
<!-- /wp:heading -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">provider_.getOperationFuture(Request r)<br />  .onTimeout(milliseconds(500), [&amp;]{<br />     doBar();  // Accesses variables in the surrounding scope<br />     return Response::onTimeout();<br />   })<br />   .then([&amp;](Response response) {<br />     if (response == Response::onTimeout()) {<br />       return;<br />     }<br />     doFoo();  // Accesses variables in the surrounding scope<br />   })<br />   .get();</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>Essentially, you force the onTimeout block to return a special instance of the Reponse object (called Response::onTimeout() here), this then becomes the input to the then block, and within the then block you can check if the response is valid and proceed accordingly. 
Yes, I know it's  ugly.
Worse, what if the Response object is complex enough that you cannot simply build a special instance of it? Or what if every possible instance of the Response object is potentially valid? Then you can go for the next remedy.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>Open up onTimeout()</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>It is useful to remember that onTimeout() is just syntactic sugar for the following. </p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">provider_.getOperationFuture(Request r)<br />   .within(milliseconds(500))<br />   .onError([](const TimedOut&amp; e){<br />      doBar();<br />     return Response::onTimeout();<br />   })<br />   .then(...);</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>So, you can use this to refactor your code to look something like this: </p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">provider_.getOperationFuture(Request r)<br />   .within(milliseconds(500))<br />   .then([&amp;](Response response) {<br />     doFoo();  // Accesses variables in the surrounding scope<br />   })<br />   .onError([&amp;](const folly::Timeout&amp; ){<br />     doBar();  // Accesses variables in the surrounding scope<br />   })<br />   .get();</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>This essentially, raises an exception after 500 milliseconds of no response, and that exception ensures that the then block is never executed!
 So, yeah, folly::Future can be tricky.</p>
<!-- /wp:paragraph -->

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="//srikanth.sastry.name/scripts-and-their-undo/">
        Scripts and their undo
      </a>
    </h1>

    <span class="post-date">11 Jan 2019</span>

    <!-- wp:cover {"url":"http://srikanth.sastry.name/wp-content/uploads/2019/01/bash-logo-672x372.png","id":313} -->
<div class="wp-block-cover has-background-dim"><p class="wp-block-cover-text"><strong>TL;DR.</strong> <em>Scripts are a great way to automate the mundane. But be sure you give yourself a way out --- an undo -- when running them.</em></p></div>
<!-- /wp:cover -->

<!-- wp:paragraph -->
<p>Some time ago, I had to carry out a long sequence of manual changes in the deployment of my ‘cloud’ service, and so like a good software engineer, I automated large chunks of these changes with shell scripts. Here I learned the importance of building and ‘undo’ in all your shell scripts that mutate the state of world.</p>
<!-- /wp:paragraph -->

<!-- wp:more {"customText":"Read more"} -->
<!--more Read more-->
<!-- /wp:more -->

<!-- wp:paragraph -->
<p> A bit of background first. I discovered that one of the services in a collection of co-located services was over-provisioned by a lot. But due to interdependence among services and second order effects, I wasn’t sure by how much. A quick way to do this was to shrink the size of this service while monitoring the resource utilization for the service. For multiple reasons, I had to go through a very specific sequence of replica turn downs, and this sequence was accounted for the automation as well.<br /> After writing and testing the script, I unleashed it on the deployment, and things seem to be going well.<br /> Midway through, an engineer from a partner team pinged me to say that they were having service incident, and they my changes was introduces a lot of noise in their monitoring dashboard making it difficult to debug their issue. So, they asked me to undo my changes, and resume it after they had fixed their issue.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Well, as it turns out, I did not have an undo script, and worse, I hadn't even thought of an undo short of resetting the entire service (which was scheduled to happen at the end of the day anyway). So, I halted my existing script, and made some quick changes that I thought would effectively undo, and given how short I was on time, I just let it run.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>You can guess what happened. Instead of undoing the changes, a bug in the script caused to be more aggressive about shutting down replicas, and I now had a new service incident on my hands! :)</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>If only I had spent enough time figuring out the undo operation, and had a handy command that executed that, this could have been completely avoided. So, my advice to you is this. When writing and launching a script that mutates the state of the world, please ensure that the script logs (either to stdout, stderr, or a log file) the exact command that can be pasted into your shell prompt to undo all the mutations. You may not have to use it often (or at all(; but when you do, it will definitely be worth the effort.</p>
<!-- /wp:paragraph -->

  </div>
  
</div>

<div class="pagination">
  
    <a class="pagination-item older" href="//srikanth.sastry.name/page5">Older</a>
  
  
    
      <a class="pagination-item newer" href="//srikanth.sastry.name/page3">Newer</a>
    
  
</div>

      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

    <script src='/public/js/script.js'></script>
  </body>
</html>
