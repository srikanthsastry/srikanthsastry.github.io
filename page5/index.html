<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <link rel="alternate" type="application/atom+xml" title="Srikanth Sastry" href="/feed.xml">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      Srikanth Sastry &middot; A Techie in Boston
    
  </title>

  
  <link rel="canonical" href="//srikanth.sastry.name/page5/">
  

  <link rel="stylesheet" href="//srikanth.sastry.name/public/css/poole.css">
  <link rel="stylesheet" href="//srikanth.sastry.name/public/css/syntax.css">
  <link rel="stylesheet" href="//srikanth.sastry.name/public/css/lanyon.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400">

  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="//srikanth.sastry.name/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="//srikanth.sastry.name/public/favicon.ico">

  <link rel="alternate" type="application/rss+xml" title="RSS" href="//srikanth.sastry.name/atom.xml">

  
</head>


  <body class="sidebar-overlay">

    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <p>A personal website</p>
  </div>

  <nav class="sidebar-nav">
    <a class="sidebar-nav-item active" href="//srikanth.sastry.name/">Home</a>

    

    
    
      
        
      
    
      
        
      
    
      
        
          <a class="sidebar-nav-item" href="//srikanth.sastry.name/about/">About</a>
        
      
    
      
        
          <a class="sidebar-nav-item" href="//srikanth.sastry.name/archives/">Archives</a>
        
      
    
      
    
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
          <a class="sidebar-nav-item" href="//srikanth.sastry.name/publications/">Publications</a>
        
      
    
      
        
          <a class="sidebar-nav-item" href="//srikanth.sastry.name/touchstone-radio-episodes/">Touchstone Radio Episodes</a>
        
      
    
    <!-- <a class="sidebar-nav-item" href="/archive/v1.1.0.zip">Download</a>
    <a class="sidebar-nav-item" href="">GitHub project</a>
    <span class="sidebar-nav-item">Currently v1.1.0</span> -->
  </nav>
  <div class="sidebar-item">
  <p>
  <a class="navbar-item" href="/feed.xml" target="_blank">Feed</a>
  </p>
  </div>
  <div class="sidebar-item">
    <p>
      &copy; 2022. All rights reserved.
    </p>
  </div>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="/" title="Home">Srikanth Sastry</a>
            <small>A Techie in Boston</small>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="posts">
  
  <div class="post">
    <h1 class="post-title">
      <a href="//srikanth.sastry.name/follyfuture-ontimeout-and-a-race-condition/">
        folly:Future, onTimeout(), and a race condition
      </a>
    </h1>

    <span class="post-date">18 Jan 2019</span>

    <!-- wp:image {"id":365,"align":"center","width":338,"height":338} -->
<div class="wp-block-image"><figure class="aligncenter is-resized"><img src="http://srikanth.sastry.name/wp-content/uploads/2019/01/C-programming-in-a-nutshell-Imgur-450x450.png" alt="" class="wp-image-365" width="338" height="338" /></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p><strong>TL;DR.</strong> The inability to cancel threads in C++ can result in bizarre semantics even in seemingly straightforward (and almost) declarative code. folly::Future is an interesting case in point.</p>
<!-- /wp:paragraph -->

<!-- wp:more -->
<!--more-->
<!-- /wp:more -->

<!-- wp:paragraph -->
<p><a href="https://github.com/facebook/folly/blob/master/folly/docs/Futures.md">Folly Futures</a> is an Async C++ framework from Facebook. It has an interesting function <a href="https://github.com/facebook/folly/blob/8757861f41c4b58ac2948ef3dc91aef9cdc8aba0/folly/futures/Future.h#L1545">onTimeout()</a>, which essentially allows to stop waiting on a Future forever. So you would typically use it as follows.</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">provider_.getOperationFuture(Request r)<br />   .then([&amp;](Response response) {<br />     doFoo();  // Accesses variables in the surrounding scope<br />   })<br />   .onTimeout(milliseconds(500), [&amp;]{<br />     doBar();  // Accesses variables in the surrounding scope<br />   })   <br />.get();</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>The semantics that I expected from this piece of code was the following: </p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">if there is no response within 500 milliseconds, then<br />   the future throws a timeout, thus executing  doBar()<br />  else<br />   the future executes the then() block, thus executing doFoo(</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>Importantly, I was expecting exactly one of the two function doFoo() or doBar() to be executed. And it turns out not be true!</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Race Condition</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>It turns out that the Future has a background thread running waiting for the response, and this thread is not cancelled upon timeout because: </p>
<!-- /wp:paragraph -->

<!-- wp:list {"ordered":true} -->
<ol><li>This thread is spawned first, and that in-turn waits on the timeout, and</li><li>C++ does not support canceling threads.</li></ol>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>So, we now have a race condition between the Future's response and timeout, thus potentially causing memory overruns and segfaults. How do you get around this? How do you use folly::Future with the semantics I outlined above? </p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Remedies</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>I found two possible ways for this.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>Swap onTimeout() and then()</h3>
<!-- /wp:heading -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">provider_.getOperationFuture(Request r)<br />  .onTimeout(milliseconds(500), [&amp;]{<br />     doBar();  // Accesses variables in the surrounding scope<br />     return Response::onTimeout();<br />   })<br />   .then([&amp;](Response response) {<br />     if (response == Response::onTimeout()) {<br />       return;<br />     }<br />     doFoo();  // Accesses variables in the surrounding scope<br />   })<br />   .get();</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>Essentially, you force the onTimeout block to return a special instance of the Reponse object (called Response::onTimeout() here), this then becomes the input to the then block, and within the then block you can check if the response is valid and proceed accordingly. 
Yes, I know it's  ugly.
Worse, what if the Response object is complex enough that you cannot simply build a special instance of it? Or what if every possible instance of the Response object is potentially valid? Then you can go for the next remedy.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>Open up onTimeout()</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>It is useful to remember that onTimeout() is just syntactic sugar for the following. </p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">provider_.getOperationFuture(Request r)<br />   .within(milliseconds(500))<br />   .onError([](const TimedOut&amp; e){<br />      doBar();<br />     return Response::onTimeout();<br />   })<br />   .then(...);</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>So, you can use this to refactor your code to look something like this: </p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">provider_.getOperationFuture(Request r)<br />   .within(milliseconds(500))<br />   .then([&amp;](Response response) {<br />     doFoo();  // Accesses variables in the surrounding scope<br />   })<br />   .onError([&amp;](const folly::Timeout&amp; ){<br />     doBar();  // Accesses variables in the surrounding scope<br />   })<br />   .get();</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>This essentially, raises an exception after 500 milliseconds of no response, and that exception ensures that the then block is never executed!
 So, yeah, folly::Future can be tricky.</p>
<!-- /wp:paragraph -->

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="//srikanth.sastry.name/scripts-and-their-undo/">
        Scripts and their undo
      </a>
    </h1>

    <span class="post-date">11 Jan 2019</span>

    <!-- wp:cover {"url":"http://srikanth.sastry.name/wp-content/uploads/2019/01/bash-logo-672x372.png","id":313} -->
<div class="wp-block-cover has-background-dim"><p class="wp-block-cover-text"><strong>TL;DR.</strong> <em>Scripts are a great way to automate the mundane. But be sure you give yourself a way out --- an undo -- when running them.</em></p></div>
<!-- /wp:cover -->

<!-- wp:paragraph -->
<p>Some time ago, I had to carry out a long sequence of manual changes in the deployment of my ‘cloud’ service, and so like a good software engineer, I automated large chunks of these changes with shell scripts. Here I learned the importance of building and ‘undo’ in all your shell scripts that mutate the state of world.</p>
<!-- /wp:paragraph -->

<!-- wp:more {"customText":"Read more"} -->
<!--more Read more-->
<!-- /wp:more -->

<!-- wp:paragraph -->
<p> A bit of background first. I discovered that one of the services in a collection of co-located services was over-provisioned by a lot. But due to interdependence among services and second order effects, I wasn’t sure by how much. A quick way to do this was to shrink the size of this service while monitoring the resource utilization for the service. For multiple reasons, I had to go through a very specific sequence of replica turn downs, and this sequence was accounted for the automation as well.<br /> After writing and testing the script, I unleashed it on the deployment, and things seem to be going well.<br /> Midway through, an engineer from a partner team pinged me to say that they were having service incident, and they my changes was introduces a lot of noise in their monitoring dashboard making it difficult to debug their issue. So, they asked me to undo my changes, and resume it after they had fixed their issue.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Well, as it turns out, I did not have an undo script, and worse, I hadn't even thought of an undo short of resetting the entire service (which was scheduled to happen at the end of the day anyway). So, I halted my existing script, and made some quick changes that I thought would effectively undo, and given how short I was on time, I just let it run.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>You can guess what happened. Instead of undoing the changes, a bug in the script caused to be more aggressive about shutting down replicas, and I now had a new service incident on my hands! :)</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>If only I had spent enough time figuring out the undo operation, and had a handy command that executed that, this could have been completely avoided. So, my advice to you is this. When writing and launching a script that mutates the state of the world, please ensure that the script logs (either to stdout, stderr, or a log file) the exact command that can be pasted into your shell prompt to undo all the mutations. You may not have to use it often (or at all(; but when you do, it will definitely be worth the effort.</p>
<!-- /wp:paragraph -->

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="//srikanth.sastry.name/merits-of-unit-tests-part-5/">
        Merits of unit tests &#8212; part 5
      </a>
    </h1>

    <span class="post-date">28 Dec 2017</span>

    <!-- wp:paragraph {"backgroundColor":"pale-cyan-blue"} -->
<p class="has-background has-pale-cyan-blue-background-color">Cross posted on <a href="https://www.linkedin.com/pulse/merits-unit-tests-part-5-srikanth-sastry/">LinkedIn</a>.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>This is the fifth, and final, post in my series of notes on unit tests. So far, we've talked about how unit tests help us in <a rel="noreferrer noopener" aria-label="documenting our code (opens in a new tab)" href="http://srikanth.sastry.name/merits-of-unit-tests-part-1/" target="_blank">documenting our code</a>, <a rel="noreferrer noopener" aria-label="reliably refactor software (opens in a new tab)" href="http://srikanth.sastry.name/the-merits-of-unit-tests-part-2/" target="_blank">reliably refactor software</a>, <a rel="noreferrer noopener" aria-label="build better code (opens in a new tab)" href="http://srikanth.sastry.name/the-merits-of-unit-tests-part-3/" target="_blank">build better code</a>, and even <a href="http://srikanth.sastry.name/unit-tests-ftw-part-4/" target="_blank" rel="noreferrer noopener" aria-label="help debugging in prod (opens in a new tab)">help debugging in prod</a>.  In this post, we'll discuss how unit tests (more precisely, the act of  writing unit tests) help us improve the usability of our code.</p>
<!-- /wp:paragraph -->

<!-- wp:more -->
<!--more-->
<!-- /wp:more -->

<!-- wp:heading -->
<h2>Usability</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>It is fairly accurate to state that the simpler and more usable your 
API is, the less likely it is to be misunderstood, misused, and abused. 
Also, simpler API constrains your possible code paths making it more 
testable and less bug-prone. I claim that the very act of making unit 
tests will help you write more usable code/API. (Of course, this assumes
 an earnest effort in writing good quality unit tests, which can be a 
topic of discussion in its own right).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The reason for my claim is simple, by writing extensive unit tests 
that account for all your use cases, you effectively become your own 
first customer. This forces you you to wear your customer's hat and 
really probe the user experience of your API. In fact, it is not 
uncommon for me to iterate on my APIs multiple times simply because I am
 not happy with how difficult it is to set up and execute my unit tests.</p>
<!-- /wp:paragraph -->

<!-- wp:quote -->
<blockquote class="wp-block-quote"><p>
  by writing extensive unit tests that account for all your use cases, you effectively become your own first customer 
</p></blockquote>
<!-- /wp:quote -->

<!-- wp:paragraph -->
<p>Let's take a fictional example of a class that does the following: It
 retrieves either a URL, or the content of the URL for a given handle 
that could potentially need to be authenticated as a specific user, and 
it can do so periodically. Here is a first crack at the API and usage 
for it.</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">class UrlRetriever {<br />   // Unauthenticated, one-time<br />   UrlRetriever(Handle handle);<br />   // Authenticated, one-time<br />   UrlRetriever(String user, Handle handle);<br />   // Authenticated, periodic<br />   UrlRetriever(String user, Handle handler, int periodInSeconds);<br />   // Unauthenticated, periodic<br />   UrlRetriever(Handle handler, int periodInSeconds);<br />   <br />   String getUrl();<br />   Blob getContents();<br />   void getContentsPeriodically(Callback cb);<br />   void getUrlPeriodically(Callback cb)<br />} </pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>When you start writing unit tests for this, you start seeing issues 
with usability. For example, you have to consider all possible 
constructions of UrlRetriever with getUrl() or getContents() call. 
Worse, what happens if the UrlRetriever is constructed without a 
periodInSeconds argument, and someone invokes getContentsPeriodically() 
on it? Sure, it is nonsensical, but you still need a test case for it, 
right? Which means, the clients could potentially misuse the class in 
this fashion, in part because the usability of this API is poor. </p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Making an honest attempt at writing unit tests can actually help you 
detect such usability issues! Consider the next iteration for the same 
use case, informed (or constrained) by the unit tests.</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">class UrlRetriever {<br />   UrlRetriever(Handle handle);<br />   AuthenticatedUrlRetriever withAuth(String user);<br />   String getUrl();<br />   Blob getContents();<br />   void getPeriodically(ContentCallback cb, int periodInSeconds);<br />   void getPeriodically(UrlCallback cb, int periodInSeconds); <br />} <br />class AuthenticatedUrlRetriever inherits UrlRetriever {<br />   // Does not make sense to authenticate with another user.<br />   AuthenticatedUrlRetriever withAuth(String user) throws exception;<br />} </pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>You will see that writing unit tests for it is much easier, and 
furthermore, there is less chance of misusing this API. Both of this is 
true because the API is more usable. The clients can use it in multiple,
 but limited/tractable. Here is how it ends up looking in the unit 
tests. </p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">// one-time unauthenticated <br />url = UrlRetriever(handle).getUrl();<br /> // periodic unauthenticated (1)<br /> // -- MyCallback inherits UrlCallback.<br />urlCallback = new MyCallback(); <br />UrlRetriever(handle).getPeriodically(urlCallback, 30);<br />  // periodic unauthenticated (2)<br /> // -- MyCallback inherits ContentCallback. <br />contentCallback = new MyCallback(); UrlRetriever(handle).getPeriodically(contentCallback, 30);<br />  // Authenticated<br />foo = UrlRetriever(handle).withAuth(user);<br /> //  -- one-time<br />blob = foo.getContents();<br /> //  -- periodic <br />foo.getPeriodically(contentCallback, 60); </pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>Much better eh? :)</p>
<!-- /wp:paragraph -->

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="//srikanth.sastry.name/unit-tests-ftw-part-4/">
        Unit tests FTW! — Part 4
      </a>
    </h1>

    <span class="post-date">28 Nov 2017</span>

    <!-- wp:paragraph {"backgroundColor":"pale-cyan-blue"} -->
<p class="has-background has-pale-cyan-blue-background-color">Cross posted on <a href="https://www.linkedin.com/pulse/unit-tests-ftw-part-4-srikanth-sastry/">LinkedIn</a></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>In the previous three  parts of this series, I have talked about how unit tests are useful in a  lot more than just verifying that your code works. We've talked its  uses for <a rel="noreferrer noopener" aria-label="documentation (opens in a new tab)" href="http://srikanth.sastry.name/merits-of-unit-tests-part-1/" target="_blank">documentation</a>, <a rel="noreferrer noopener" aria-label="refactoring and code health (opens in a new tab)" href="http://srikanth.sastry.name/the-merits-of-unit-tests-part-2/" target="_blank">refactoring and code health</a>, and <a rel="noreferrer noopener" aria-label="writing better software (opens in a new tab)" href="http://srikanth.sastry.name/the-merits-of-unit-tests-part-3/" target="_blank">writing better software</a>. Next, we'll see how unit tests helps you debug issues in production. </p>
<!-- /wp:paragraph -->

<!-- wp:more -->
<!--more-->
<!-- /wp:more -->

<!-- wp:heading {"level":3} -->
<h3>Debugging </h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>A single unit test is supposed to test a single code path within your
 class. I don't always follow this maxim, but it is nevertheless a very 
good rule of thumb. Given that the number of code paths within a given 
code if often increases exponentially with the size of the code, unit 
tests are often a lot more lines of code than the actual production code
 itself. This is a good thing when it comes to debugging.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>If your unit tests cover sufficiently many code paths (which any good
 unit test suite should do), then when an issue arises in production, 
and you narrow it down to your code, then you know that the offending 
code path could not have been the several code paths that your unit 
tests already covered. This pruning makes your debugging a lot simpler 
than before.</p>
<!-- /wp:paragraph -->

<!-- wp:quote -->
<blockquote class="wp-block-quote"><p>
  Unit tests can prune the possible set of offending code paths to make debugging tractable, 
</p></blockquote>
<!-- /wp:quote -->

<!-- wp:paragraph -->
<p><strong>EXAMPLE</strong></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Let's go back to the example I gave you in <a href="https://www.linkedin.com/pulse/merits-unit-tests-part-3-srikanth-sastry/" target="_blank" rel="noreferrer noopener">Part 3</a>.
 Here is that piece of code. Recall that it takes a large query, splits 
it up into multiple subqueries, sends them off in parallel, collects 
their responses back, munges them and returns the munged response to the
 caller via a callback </p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">public class QueryManager {<br />   void sendRequest(Query query, Callback queryCallback) {<br />     List&lt;Subquery&gt; subqueries = splitQuery(query);<br />     for (Subquery subquery : subqueries) {<br />       sendQuery(subquery, new Subquery.Callback() {<br />           @Override<br />           public onSuccess(Response response) {<br />             // Do some processing. ...<br />             if (allResponses()) {<br />               queryCallback.finalResult();<br />              } else {<br />                queryCallback.incrementalResult();<br />              }<br />            }<br />            @Override<br />            public onFailure(Error e) {<br />              // Do some error handling. ... <br />              if (allResponses()) {<br />                queryCallback.finalResult();<br />              }<br />            }<br />          });<br />     }<br />   }<br />     // Other methods. ... <br />} </pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>I ran into this code because of an issue that we were seeing in production. </p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Every so often the logs showed a really really long query that timed 
out, but it did manage to serve the response back to the user. Digging 
into it some more, I managed to narrow it down to this class. But beyond
 that, things were a mystery. Recall that in my last post I mentioned 
how there were no unit tests here, and the code actually needed 
refactoring to pull out the anonymous class. We pick up the story here 
after all that.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Once I had all the unit tests put in, I discovered that the root cause for the bug is actually a race condition.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The unit tests had ruled out sufficiently many code paths to lead me 
to a strong suspicion that it was a race condition in the allresponses()
 function causing two overlapping 'last' responses to both trigger the 
incrementalResult() callback function, and so the finalResult() method 
was never invoked. </p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Once you have a candidate cause, reproducing and verifying it becomes
 pretty straightforward (not necessarily easy or simple, but 
straightforward), and the rest is just mundane software engineering. </p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>See, unit tests are more than a one trick pony! :)</p>
<!-- /wp:paragraph -->

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="//srikanth.sastry.name/the-merits-of-unit-tests-part-3/">
        The merits of unit tests — Part 3
      </a>
    </h1>

    <span class="post-date">22 Nov 2017</span>

    <!-- wp:paragraph {"backgroundColor":"pale-cyan-blue"} -->
<p class="has-background has-pale-cyan-blue-background-color">Cross posted on <a href="https://www.linkedin.com/pulse/merits-unit-tests-part-3-srikanth-sastry/">LinkedIn</a>.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Previously, I talked about how unit tests serve purposes other than verifying code functionality; I talked about <a rel="noreferrer noopener" aria-label=" (opens in a new tab)" href="http://srikanth.sastry.name/merits-of-unit-tests-part-1/" target="_blank">unit tests serving as defacto documentation</a>, and <a href="http://srikanth.sastry.name/the-merits-of-unit-tests-part-2/" target="_blank" rel="noreferrer noopener" aria-label=" (opens in a new tab)">unit tests helping you refactor without fear</a>. In this post, I'll talk about yet another benefit to unit tests: writing better software.</p>
<!-- /wp:paragraph -->

<!-- wp:more -->
<!--more-->
<!-- /wp:more -->

<!-- wp:heading -->
<h2>Better software design</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>I am not talking about writing bug-free software here. Sure, good 
unit tests help you discover/avoid large classes of bugs, but that's not
 the point. Unit tests also help you enforce good design patterns and 
modularity in your software.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Unit tests help you with software design in two complementary ways. 
First, they help you establish optimal boundaries of modularity in terms
 of methods, and classes, and second, they help you understand your 
dependencies better and almost force you to use good dependency 
injection hygiene.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>Modularity</h3>
<!-- /wp:heading -->

<!-- wp:image {"id":386} -->
<figure class="wp-block-image"><img src="http://srikanth.sastry.name/wp-content/uploads/2019/01/0-2.jpg" alt="" class="wp-image-386" /></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>How do you know that your class or method does 'too much', or that it
 has undesirable side-effects? A pretty good way to discover it is to 
start writing unit tests for it. If you find yourself having to test for
 too many different types of inputs, then your methods are doing too 
much. If you find yourself having to test for too many orderings of 
operations, when your methods have too many side effects. It really is 
just as simple as that!</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>For instance, some time ago, I came across a piece of code that 
essentially took a large query, split it up into multiple subqueries, 
sent them off in parallel, collected their responses back, munged them 
and returned the munged response to the caller via a callback. The code 
looked something like this:</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">public class QueryManager {<br />   void sendRequest(Query query, Callback queryCallback) {<br />     List&lt;Subquery&gt; subqueries = splitQuery(query);<br />     for (Subquery subquery : subqueries) {<br />       sendQuery(subquery, new Subquery.Callback() {<br />           @Override<br />           public onSuccess(Response response) {<br />             // Do some processing. ...<br />             if (allResponses()) {<br />               queryCallback.finalResult();<br />              } else {<br />                queryCallback.incrementalResult();<br />              }<br />            }<br />            @Override<br />            public onFailure(Error e) {<br />              // Do some error handling. ... <br />              if (allResponses()) {<br />                queryCallback.finalResult();<br />              }<br />            }<br />          });<br />     }<br />   }<br />     // Other methods. ... <br />} </pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>This code makes for an interesting case study on multiple fronts, and  I will come back to it in a later post. For now, it is sufficient to  state that I wanted to make changes to this code, but it was pretty  thorny because (you guessed it!) it has no unit tests.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Naturally, the first step is to write unit tests for this class, and 
that was when I realized why there were no unit tests here. This class 
is incredibly tricky to unit test. Getting the subqueries to respond 
under various conditions and ordering resulted in a combinatorial 
explosion of test cases making the task intractable. This was very 
strong code smell.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>As you have probably figured out already, this was a classic case of a
 single class doing too much. The primary culprit was the anonymous 
class that implemented the Subquery.Callback interface. It should really
 have been its own class with its own unit tests.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>After I pulled out that anonymous class into its own class, it became
 a lot easier to unit test both the Subquery.Callback and the 
QueryManager individually, and with that, the code became much more 
modular, easier to read, and much easier to maintain.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>Dependency</h3>
<!-- /wp:heading -->

<!-- wp:image {"id":387} -->
<figure class="wp-block-image"><img src="http://srikanth.sastry.name/wp-content/uploads/2019/01/0-3.jpg" alt="" class="wp-image-387" /></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>If your code does not do a decent job of<a href="https://en.wikipedia.org/wiki/Dependency_injection" target="_blank" rel="noreferrer noopener"> injecting its dependencies</a>
 from outside, you are gonna have a bad time! Having good unit tests 
will actually keep you from getting into this pitfall pretty 
effectively. Consider the following contrived example. You have a piece 
of code that writes to an external service, and your code throttles the 
rate of writes because going over your approved rate/quota can be pretty
 expensive. So, your code could look something like this:</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">class RateLimiter {<br />   void writeToExternalService(const vector&lt;Entries&gt;&amp; stuff) {<br />     auto service = new ExternalService(ConnectionParameters foo);<br />     for (auto entry : stuff) {<br />       waitUntilQuotaAvailable();<br />       service.write(entry);<br />     }<br />   }<br />} </pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>Remember how I said that going over the rate/quota is bad? How do you
 verify that it will not happen? Well, you could set up an elaborate 
testbed that has an ExternalService simulator, and you can run your code
 through all sorts of inputs and verify that the simulator says that the
 rate limiting is work. But that's expensive, and if you choose to go 
with a different external service, then well, good luck with that!</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Instead, you could try to unit test it. But how? You need to have 
access to the ExternalService to do that, which we have already 
established is expensive! Well, this is where unit testing it will force
 you into healthy dependency injection. For this contrived example, you 
can inject the dependency as follows.</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">class RateLimiter {<br />   void writeToExternalService(<br />       const vector&lt;Entries&gt;&amp; stuff, <br />       ExternalService service) {<br />     for (auto entry : stuff) {<br />       waitUntilQuotaAvailable();<br />       service.write(entry);<br />     }<br />   }<br />} </pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>Your unit tests could do this:</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">TEST(AwesomeTestCase, testWrite) {<br />   vector&lt;Entries&gt; stuff = generateLotsOfStuff();<br />   RateLimits limit;  // Set your limits here.<br />   ExternalService svc = MockExternalService(limit);<br />   RateLimiter rateLimiter = new RateLimiter(limit); <br />   rateLimiter.writeToExternalService(stuff, svc);<br />   ASSERT_TRUE(svc.writesWithinLimits()); <br />} </pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>And you can put your implementation through the wringer without breaking a sweat.</p>
<!-- /wp:paragraph -->

  </div>
  
</div>

<div class="pagination">
  
    <a class="pagination-item older" href="//srikanth.sastry.name/page6">Older</a>
  
  
    
      <a class="pagination-item newer" href="//srikanth.sastry.name/page4">Newer</a>
    
  
</div>

      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

    <script src='/public/js/script.js'></script>
  </body>
</html>
