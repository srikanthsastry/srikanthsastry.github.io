<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <link rel="alternate" type="application/atom+xml" title="Srikanth Sastry" href="/feed.xml">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      In unit tests, I favor Detroit over London &middot; Srikanth Sastry
    
  </title>

  
  <link rel="canonical" href="//srikanth.sastry.name/in-unit-tests-favor-detroit-over-london/">
  

  <link rel="stylesheet" href="//srikanth.sastry.name/public/css/poole.css">
  <link rel="stylesheet" href="//srikanth.sastry.name/public/css/syntax.css">
  <link rel="stylesheet" href="//srikanth.sastry.name/public/css/lanyon.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400">

  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="//srikanth.sastry.name/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="//srikanth.sastry.name/public/favicon.ico">

  <link rel="alternate" type="application/rss+xml" title="RSS" href="//srikanth.sastry.name/atom.xml">

  
</head>


  <body class="sidebar-overlay theme-base-08">

    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <p>A personal website</p>
  </div>

  <nav class="sidebar-nav">
    <a class="sidebar-nav-item" href="//srikanth.sastry.name/">Home</a>

    

    
    
      
        
      
    
      
        
      
    
      
        
          <a class="sidebar-nav-item" href="//srikanth.sastry.name/about/">About</a>
        
      
    
      
        
          <a class="sidebar-nav-item" href="//srikanth.sastry.name/archives/">Archives</a>
        
      
    
      
    
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
          <a class="sidebar-nav-item" href="//srikanth.sastry.name/publications/">Publications</a>
        
      
    
      
        
          <a class="sidebar-nav-item" href="//srikanth.sastry.name/touchstone-radio-episodes/">Touchstone Radio Episodes</a>
        
      
    
    <!-- <a class="sidebar-nav-item" href="/archive/v1.1.0.zip">Download</a>
    <a class="sidebar-nav-item" href="">GitHub project</a>
    <span class="sidebar-nav-item">Currently v1.1.0</span> -->
  </nav>
  <div class="sidebar-item">
  <p>
  <a class="navbar-item" href="/feed.xml" target="_blank">Feed</a>
  </p>
  </div>
  <div class="sidebar-item">
    <p>
      &copy; 2025. All rights reserved.
    </p>
  </div>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="/" title="Home">Srikanth Sastry</a>
            <small>A Techie in Boston</small>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="post">
  <h1 class="post-title">In unit tests, I favor Detroit over London</h1>
  <span class="post-date">26 Jun 2022</span>
  <p><img src="/images/detroit-wall-frame.jpg" alt="" /></p>

<p><a href="/defining-unit-tests-two-schools-of-thought/">Recall</a> the two schools of thought around unit test: Detroit, and London. Briefly, the Detroit school considers a ‘unit’ of software to be tested as a ‘behavior’ that consists of one or more classes, and unit tests replace only shared and/or external dependencies with test doubles. In contrast, the London school consider a ‘unit’ to be a single class, and replaces all dependencies with test doubles.</p>

<table>
  <thead>
    <tr>
      <th>School</th>
      <th>Unit</th>
      <th>Isolation</th>
      <th>Speed</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Detroit</td>
      <td>Behavior</td>
      <td>Replace shared and external dependencies with test doubles</td>
      <td>‘fast’</td>
    </tr>
    <tr>
      <td>London</td>
      <td>Class</td>
      <td>Replace all dependencies (internal, external, shared, etc.) with test doubles</td>
      <td>‘fast’</td>
    </tr>
  </tbody>
</table>

<p>See this <a href="/defining-unit-tests-two-schools-of-thought/">note</a> for a more detailed discussion on the two schools.</p>

<p>Each school have it’s proponents and each school of thought has it’s advantages. I, personally, prefer the Detroit school over the London school. I have noticed that following the Detroit school has made my test suite more <a href="/unit-test-attributes-and-their-trade-offs/">accurate and complete</a>.</p>

<h2 id="improved-accuracy-when-refactoring">Improved Accuracy (when refactoring)</h2>

<p>In <a href="/unit-test-attributes-and-their-trade-offs/">the post on attributes of a unit test suite</a>, I defined <em>accuracy</em> as the measure of how likely it is that a test failure denotes a bug in your diff. I have noticed that unit test suites that follow the Detroit school tended to have high accuracy when your codebase has a lot of classes that are public <em>de jour</em>, but private <em>de facto</em>.</p>

<p>Codebases I have worked in typically have hundreds of classes, but only a handful of those classes are actually referenced by external classes/services. Most of the classes are part of a private API that is internal to the service. Let’s take a concrete illustration. Say, there is a class <code class="language-plaintext highlighter-rouge">Util</code> that is used only by classes <code class="language-plaintext highlighter-rouge">Feature1</code> and <code class="language-plaintext highlighter-rouge">Feature2</code> within the codebase, and has no other callers; in fact, <code class="language-plaintext highlighter-rouge">Util</code> exists only to help classes <code class="language-plaintext highlighter-rouge">Feature1</code> and <code class="language-plaintext highlighter-rouge">Feature2</code> implement their respective user journies. Here although <code class="language-plaintext highlighter-rouge">Util</code> is a class with public methods, in reality <code class="language-plaintext highlighter-rouge">Util</code> really represents the common implementation details for <code class="language-plaintext highlighter-rouge">Feature1</code> and <code class="language-plaintext highlighter-rouge">Feature2</code>.</p>

<h3 id="in-london">In London</h3>
<p>According to the London school, all unit tests for <code class="language-plaintext highlighter-rouge">Feature1</code> and <code class="language-plaintext highlighter-rouge">Fearure2</code> should be replacing <code class="language-plaintext highlighter-rouge">Util</code> with a test double. Thus, tests for <code class="language-plaintext highlighter-rouge">Feature1</code> and <code class="language-plaintext highlighter-rouge">Feature2</code> look as follows.
<img src="/images/London-School-Accuracy-Before.png" alt="" /></p>

<p>Now, say we want to do some refactoring that spans <code class="language-plaintext highlighter-rouge">Feature1</code>, <code class="language-plaintext highlighter-rouge">Feature2</code>, and <code class="language-plaintext highlighter-rouge">Util</code>. Since <code class="language-plaintext highlighter-rouge">Util</code> is really has a private API with <code class="language-plaintext highlighter-rouge">Feature1</code> and <code class="language-plaintext highlighter-rouge">Feature2</code>, we can change the API of <code class="language-plaintext highlighter-rouge">Util</code> in concert with <code class="language-plaintext highlighter-rouge">Feature1</code> and <code class="language-plaintext highlighter-rouge">Feature2</code> in a single diff. Now, since the tests for <code class="language-plaintext highlighter-rouge">Feature1</code> and <code class="language-plaintext highlighter-rouge">Feature2</code> use test doubles for <code class="language-plaintext highlighter-rouge">Util</code>, and we have changed <code class="language-plaintext highlighter-rouge">Util</code>’s API, we need to change the test doubles’ implementation to match the new API. After making these changes, say, the tests for <code class="language-plaintext highlighter-rouge">Util</code> pass, but the tests for <code class="language-plaintext highlighter-rouge">Feature1</code> fail.</p>

<p><img src="/images/London-School-Accuracy-After.png" alt="" /></p>

<p>Now, does the test failure denote a bug in our refactoring, or does it denote an error in how we modified the tests? This is not easy to determine except by stepping through the tests manually. Thus, the test suite does not have high accuracy.</p>

<h3 id="in-detroit">In Detroit</h3>
<p>In contrast, according to the Detroit school, the unit tests for <code class="language-plaintext highlighter-rouge">Feature1</code> and <code class="language-plaintext highlighter-rouge">Feature2</code> can use <code class="language-plaintext highlighter-rouge">Util</code> as such (without test doubles). The tests for <code class="language-plaintext highlighter-rouge">Feature1</code> and <code class="language-plaintext highlighter-rouge">Feature2</code> look as follows.</p>

<p><img src="/images/Detroit-School-Accuracy-Before.png" alt="" /></p>

<p>If we do the same refactoring across <code class="language-plaintext highlighter-rouge">Feature1</code>, <code class="language-plaintext highlighter-rouge">Feature2</code>, and <code class="language-plaintext highlighter-rouge">Util</code> classes, note that we do not need to make any changes to the tests for <code class="language-plaintext highlighter-rouge">Feature1</code> and <code class="language-plaintext highlighter-rouge">Feature2</code>. If the tests fail, then we have a very high signal that the refactoring has a bug in it; this makes for a high accuracy test suite!</p>

<p><img src="/images/Detroit-School-Accuracy-After.png" alt="" /></p>

<p>Furthermore, since <code class="language-plaintext highlighter-rouge">Util</code> exists only to serve <code class="language-plaintext highlighter-rouge">Feature1</code> and <code class="language-plaintext highlighter-rouge">Feature2</code>, you can argue that <code class="language-plaintext highlighter-rouge">Util</code> doesn’t even need any unit tests of it’s own; the tests for <code class="language-plaintext highlighter-rouge">Feature1</code> and <code class="language-plaintext highlighter-rouge">Feature2</code> cover the spread!</p>

<h2 id="improved-completeness-around-regressions">Improved Completeness (around regressions)</h2>
<p>In <a href="/unit-test-attributes-and-their-trade-offs/">the post on attributes of a unit test suite</a>, I defined <em>completeness</em> as the measure of how likely a bug introduced by your diff is caught by your test suite. I have seen unit tests following the Detroit school catching bugs/regressions more easily, especially when the bugs are introduced by API contract violations.</p>

<p>It easier to see this with an example. Say, there is a class <code class="language-plaintext highlighter-rouge">Outer</code> that uses a class <code class="language-plaintext highlighter-rouge">Inner</code>, and <code class="language-plaintext highlighter-rouge">Inner</code> is an internal non-shared dependency. Let’s say that the class <code class="language-plaintext highlighter-rouge">Outer</code> depends on a specific contract, (let’s call it) alpha, that <code class="language-plaintext highlighter-rouge">Inner</code>’s API satisfies, for correctness. Recall that we practically trade off between the speed of a test suite and it’s completeness, let us posit that the incompleteness here is that we do not have a test for <code class="language-plaintext highlighter-rouge">Inner</code> satisfying contract alpha.</p>

<h3 id="in-london-1">In London</h3>

<p>Following the London school, the tests for <code class="language-plaintext highlighter-rouge">Outer</code> replace the instance of <code class="language-plaintext highlighter-rouge">Inner</code> with a test double, and since the test double is a replacement for <code class="language-plaintext highlighter-rouge">Inner</code>, it also satisfies contract alpha. See the illustration below for clarity.</p>

<p><img src="/images/London-School-Completeness-Before.png" alt="Image not found: /images/London-School-Completeness-Before.png" title="Image not found: /images/London-School-Completeness-Before.png" /></p>

<p>Now, let’s assume that we have a diff that ‘refactors’ <code class="language-plaintext highlighter-rouge">Inner</code>, but in that process, it introduces a bug that violates contract alpha. Since we have assumed an incompleteness in our test suite around contract alpha, the unit test for <code class="language-plaintext highlighter-rouge">Inner</code> does not catch this regression. Also, since the tests for <code class="language-plaintext highlighter-rouge">Outer</code> use a test double for <code class="language-plaintext highlighter-rouge">Inner</code> (which satisfies contract alpha), those tests do not detect this regression either.</p>

<p><img src="/images/London-School-Completeness-After.png" alt="" /></p>

<h3 id="in-detroit-1">In Detroit</h3>

<p>If we were to follow the Detroit school instead, then the unit tests for <code class="language-plaintext highlighter-rouge">Outer</code> instantiate and use <code class="language-plaintext highlighter-rouge">Inner</code> when testing the correctness of <code class="language-plaintext highlighter-rouge">Outer</code>, as shown below. Note that the test incompletness w.r.t. contract alpha still exists.
<img src="/images/Detroit-School-Completeness-Before.png" alt="" /></p>

<p>Here, like before, assume that we have a diff that ‘refactors’ <code class="language-plaintext highlighter-rouge">Inner</code> and breaks contract alpha. This time around, although the test suite for <code class="language-plaintext highlighter-rouge">Inner</code> does not catch the regression, the test suite for <code class="language-plaintext highlighter-rouge">Outer</code> will catch the regression. Why? Because the correctness of <code class="language-plaintext highlighter-rouge">Outer</code> depends on <code class="language-plaintext highlighter-rouge">Inner</code> satisfying contract alpha. When that contract is violated <code class="language-plaintext highlighter-rouge">Outer</code> fails to satisfy correctness, and is therefore, it’s unit tests fail/</p>

<p><img src="/images/Detroit-School-Completeness-After.png" alt="" /></p>

<p>In effect, even though we did not have an explicit test for contract alpha, the unit tests written according to the Detroit school tend to have better completeness than the ones written following the London school.</p>

</div>




      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

    <script src='/public/js/script.js'></script>
  </body>
</html>
