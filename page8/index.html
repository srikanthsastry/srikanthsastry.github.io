<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <link rel="alternate" type="application/atom+xml" title="Srikanth Sastry" href="/feed.xml">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      Srikanth Sastry &middot; A Techie in Boston
    
  </title>

  
  <link rel="canonical" href="//srikanth.sastry.name/page8/">
  

  <link rel="stylesheet" href="//srikanth.sastry.name/public/css/poole.css">
  <link rel="stylesheet" href="//srikanth.sastry.name/public/css/syntax.css">
  <link rel="stylesheet" href="//srikanth.sastry.name/public/css/lanyon.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400">

  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="//srikanth.sastry.name/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="//srikanth.sastry.name/public/favicon.ico">

  <link rel="alternate" type="application/rss+xml" title="RSS" href="//srikanth.sastry.name/atom.xml">

  
</head>


  <body class="sidebar-overlay">

    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <p>A personal website</p>
  </div>

  <nav class="sidebar-nav">
    <a class="sidebar-nav-item active" href="//srikanth.sastry.name/">Home</a>

    

    
    
      
        
      
    
      
        
      
    
      
        
          <a class="sidebar-nav-item" href="//srikanth.sastry.name/about/">About</a>
        
      
    
      
        
          <a class="sidebar-nav-item" href="//srikanth.sastry.name/archives/">Archives</a>
        
      
    
      
    
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
          <a class="sidebar-nav-item" href="//srikanth.sastry.name/publications/">Publications</a>
        
      
    
      
        
          <a class="sidebar-nav-item" href="//srikanth.sastry.name/touchstone-radio-episodes/">Touchstone Radio Episodes</a>
        
      
    
    <!-- <a class="sidebar-nav-item" href="/archive/v1.1.0.zip">Download</a>
    <a class="sidebar-nav-item" href="">GitHub project</a>
    <span class="sidebar-nav-item">Currently v1.1.0</span> -->
  </nav>
  <div class="sidebar-item">
  <p>
  <a class="navbar-item" href="/feed.xml" target="_blank">Feed</a>
  </p>
  </div>
  <div class="sidebar-item">
    <p>
      &copy; 2022. All rights reserved.
    </p>
  </div>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="/" title="Home">Srikanth Sastry</a>
            <small>A Techie in Boston</small>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="posts">
  
  <div class="post">
    <h1 class="post-title">
      <a href="//srikanth.sastry.name/moving-to-google/">
        Moving to Google
      </a>
    </h1>

    <span class="post-date">23 Apr 2013</span>

    <p>Today, I start my new life as a software engineer with Google. It feels strange moving away from academia after over 9 years. Hope this bodes well for me! :-)</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="//srikanth.sastry.name/wait-free-stabilizing-dining-using-regular-registers/">
        Wait-Free Stabilizing Dining Using Regular Registers
      </a>
    </h1>

    <span class="post-date">18 Jan 2013</span>

    <p>This paper was presented at OPODIS 2012.</p>

<p><em><strong>Abstract:</strong></em> Dining philosophers is a scheduling paradigm that determines when processes in a distributed system should execute certain sections of their code so that processes do not execute <code class="language-plaintext highlighter-rouge">conflicting' code sections concurrently, for some application-dependent notion of a </code>conflict’. Designing a stabilizing dining algorithm for shared-memory systems subject to process crashes presents an interesting challenge: classic stabilization relies on all processes continuing to execute actions forever, an assumption which is violated when crash failures are considered. We present a dining algorithm that is both wait-free (tolerates any number of crashes) and is pseudo-stabilizing. Our algorithm works in an asynchronous system in which processes communicate via shared regular registers and have access to the eventually perfect failure detector $\Diamond P$. Furthermore, with a stronger failure detector, the solution becomes wait-free and self-stabilizing. To our knowledge, this is the first such algorithm. Prior results show that $\Diamond P$ is necessary for wait-freedom.</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="//srikanth.sastry.name/leader-election-using-loneliness-detection/">
        Leader Election Using Loneliness Detection
      </a>
    </h1>

    <span class="post-date">11 Oct 2012</span>

    <p>My recent work titled “Leader Election Using Loneliness Detection” is accepted for presentation at the 25th International Symposium on DIStributed Computing (DISC) in Rome, and in the journal Distributed Computing. Briefly, the work focuses on the ‘gap in the computational power’ in single-hop wireless systems when the information about message loss in the system is varied.</p>

<!--more-->

<p>We assume that the cause of message loss in wireless networks is collision, which happens when multiple nodes in the system transmit concurrently. We consider two models — weak collision detection (WCD) and strong collision detection (SCD) — which differ only with respect to the information that they provide about message loss. Specifically, when message collision occurs, in WCD systems, all the nodes that are not transmitting (and therefore listening) receive information about the collision whereas the transmitting processes do not receive any such information, and in SCD systems, all the nodes (both transmitting and receiving nodes) receive information about the collision. Intuitively, it makes sense to argue that SCD systems are more `powerful’ than WCD systems because SCD systems provide more information about message collision than WCD systems; however, that does not answer the question: How much more powerful are SCD systems than WCD systems; how can the ‘gap’ be characterized? Alternatively, we may ask: how do we quantify the amount of information that is provided to transmitting processes when they are notified of a message collision?</p>

<p>We showed that the ‘gap’ between SCD and WCD systems is captured by the answer to the question: Is there exactly one node in the system? In other words, if WCD systems were to be augmented with an oracle that provides the answer to the foregoing question, then such a system would be able to solve all the problems solvable in SCD systems with the same time and message complexity (modulo a constant factor). We call such an oracle a Loneliness Detector (or LD, for short). We showed that LD can be implemented in WCD systems in O(log u - log n) time deterministically (where u is an upper bound on the number of nodes in the system and n is the actual number of nodes in the system) and in O(1) time with high probability. We then used LD to compare the time complexity of solving leader election in SCD and WCD systems. We showed that in both SCD and WCD systems, leader election may be solved in O(log u) time deterministically and in O(loglog n + log(1/epsilon)) time probabilistically, where epsilon is the error probability. We also provided matching lower bounds for each of the upper bounds presented, thus demonstrating the efficiency of our algorithms.</p>

<p><em><strong>Abstract:</strong></em></p>
<blockquote>We consider the problem of leader election (LE) in single-hop radio networks with synchronized time slots for transmitting and receiving messages. We assume that the actual number n of processes is unknown, while the size u of the ID space is known, but is possibly much larger. We consider two types of collision detection: strong (SCD), whereby all processes detect collisions, and weak (WCD), whereby only non-transmitting processes detect collisions. We introduce loneliness detection (LD) as a key subproblem for solving LE in WCD systems. LD informs all processes whether the system contains exactly one process or more than one. We show that LD captures the difference in power between SCD and WCD, by providing an implementation of SCD over WCD and LD. We present two algorithms that solve deterministic and probabilistic LD in WCD systems with time costs of O(log u/n ) and O(min(log u/n , log(1/epsilon)/n)), respectively, where epsilon is the error probability. We also provide matching lower bounds. We present two algorithms that solve deterministic and probabilistic LE in SCD systems with time costs of O(log u) and O(min(log u, log log n + log( 1/epsilon ))), respectively, where epsilon is the error probability. We provide matching lower bounds.</blockquote>
<p>The full version of the paper may be <a href="http://hdl.handle.net/1721.1/66224">found here [link]</a>.</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="//srikanth.sastry.name/asynchronous-failure-detectors/">
        Asynchronous Failure Detectors
      </a>
    </h1>

    <span class="post-date">16 May 2012</span>

    <p>My latest work on a modeling framework for a special variant of failure detectors is accepted at the 31st Annual ACM SIGACT-SIGOPS Symposium on Principles of Distributed Computing. <a title="Asynchronous Failure Detectors" href="/documents/research/AFD-podc2012.pdf">A preprint of the submission is available [here]</a>.</p>

<p><strong>Update:</strong> <a title="Asynchronous Failure Detectors: Tech Report" href="http://hdl.handle.net/1721.1/76716" target="_blank">The full version is available as a tech report [here].</a></p>

<!--more-->

<p><em><strong>Abstract: </strong></em>Failure detectors — oracles that provide information about process crashes — are an important abstraction for crash tolerance in distributed systems. Although current failure-detector theory provides great generality and expressiveness, it also poses significant challenges in developing a robust hierarchy of failure detectors. We address some of these challenges by proposing a variant of failure detectors called asynchronous failure detectors and an associated modeling framework. Unlike the traditional failure-detector framework, our framework eschews real time completely. We show that asynchronous failure detectors are sufficiently expressive to include several popular failure detectors. Additionally, we show that asynchronous failure detectors satisfy many desirable properties: they are self-implementable, guarantee that stronger asynchronous failure detectors solve more problems, and ensure that their outputs encode no information other than process crashes. We introduce the notion of a failure detector being representative of a problem to capture the idea that some problems encode the same information about process crashes as their weakest failure detectors do. We show that a large class of problems, called finite problems, do not have representative failure detectors.</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="//srikanth.sastry.name/failure-detectors-encapsulate-fairness/">
        Failure Detectors Encapsulate Fairness
      </a>
    </h1>

    <span class="post-date">17 Feb 2012</span>

    <p>The full version of my OPODIS 2010 paper “Failure Detectors Encapsulate Fairness” (<a href="documents/research/opodis2010.pdf" target="_blank">preprint</a>) has been accepted for publication with the journal Distributed Computing. You can find a <a href="/documents/research/journal/FD_encapsulate_fairness_preprint.pdf" target="_blank">preprint of the paper here [pdf]</a>.</p>

<!--more-->

<p><em><strong>Abstract: </strong></em>Failure detectors have long been viewed as abstractions for the synchronism present in distributed system models. However, investigations into the exact amount of synchronism encapsulated by a given failure detector have met with limited success. The reason for this is that traditionally, models of partial synchrony are specified with respect to real time, but failure detectors do not encapsulate real time. Instead, we argue that failure detectors encapsulate the fairness in computation and communication. Fairness is a measure of the number of steps executed by one process relative either to the number of steps taken by another process or relative to the duration for which a message is in transit. We argue that failure detectors are substitutable for the fairness properties (rather than real-time properties) of partially synchronous systems. We propose four fairness-based models of partial synchrony and demonstrate that they are, in fact, the ‘weakest system models’ to implement the canonical failure detectors from the Chandra-Toueg hierarchy. We also propose a set of fairness-based models which encapsulate the $Gc$ parametric failure detectors which eventually and permanently suspect crashed processes, and eventually and permanently trust some fixed set of c correct processes.</p>

  </div>
  
</div>

<div class="pagination">
  
    <a class="pagination-item older" href="//srikanth.sastry.name/page9">Older</a>
  
  
    
      <a class="pagination-item newer" href="//srikanth.sastry.name/page7">Newer</a>
    
  
</div>

      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

    <script src='/public/js/script.js'></script>
  </body>
</html>
