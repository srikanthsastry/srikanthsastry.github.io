<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <link rel="alternate" type="application/atom+xml" title="Srikanth Sastry" href="/feed.xml">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      Tests should be isolated from each other; not coupled &middot; Srikanth Sastry
    
  </title>

  
  <link rel="canonical" href="//srikanth.sastry.name/tests-should-be-isolated-not-coupled/">
  

  <link rel="stylesheet" href="//srikanth.sastry.name/public/css/poole.css">
  <link rel="stylesheet" href="//srikanth.sastry.name/public/css/syntax.css">
  <link rel="stylesheet" href="//srikanth.sastry.name/public/css/lanyon.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400">

  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="//srikanth.sastry.name/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="//srikanth.sastry.name/public/favicon.ico">

  <link rel="alternate" type="application/rss+xml" title="RSS" href="//srikanth.sastry.name/atom.xml">

  
</head>


  <body class="sidebar-overlay">

    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <p>A personal website</p>
  </div>

  <nav class="sidebar-nav">
    <a class="sidebar-nav-item" href="//srikanth.sastry.name/">Home</a>

    

    
    
      
        
      
    
      
        
      
    
      
        
          <a class="sidebar-nav-item" href="//srikanth.sastry.name/about/">About</a>
        
      
    
      
        
          <a class="sidebar-nav-item" href="//srikanth.sastry.name/archives/">Archives</a>
        
      
    
      
    
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
          <a class="sidebar-nav-item" href="//srikanth.sastry.name/publications/">Publications</a>
        
      
    
      
        
          <a class="sidebar-nav-item" href="//srikanth.sastry.name/touchstone-radio-episodes/">Touchstone Radio Episodes</a>
        
      
    
    <!-- <a class="sidebar-nav-item" href="/archive/v1.1.0.zip">Download</a>
    <a class="sidebar-nav-item" href="">GitHub project</a>
    <span class="sidebar-nav-item">Currently v1.1.0</span> -->
  </nav>
  <div class="sidebar-item">
  <p>
  <a class="navbar-item" href="/feed.xml" target="_blank">Feed</a>
  </p>
  </div>
  <div class="sidebar-item">
    <p>
      &copy; 2022. All rights reserved.
    </p>
  </div>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="/" title="Home">Srikanth Sastry</a>
            <small>A Techie in Boston</small>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="post">
  <h1 class="post-title">Tests should be isolated from each other; not coupled</h1>
  <span class="post-date">03 Jul 2022</span>
  <p><img src="/images/carabiners-connected.jpg" alt="" />
Almost <a href="/defining-unit-tests-two-schools-of-thought/">by definition</a> unit tests should be <em>isolated</em> from its (external, shared) dependencies. But, equally importantly, unit tests should also be isolated <em>from each other</em>. When one test starts to affect another test, the two tests are said to be <em>coupled</em>. Alternatively, if changes to one test <em>can</em> negatively impact the correctness of another test, then the two tests are said to be <em>coupled</em>.</p>

<p>Coupled tests are problematic in two ways.</p>

<ol>
  <li><em>Tests become less readable.</em> Reading the code for a single unit test does not necessarily communicate what the test does. We also need to understand the ‘coupling’ between that test and other tests to grok what a single test does. This coupling can be subtle and not easy to follow.</li>
  <li><em>Tests become less <a href="/unit-test-attributes-and-their-trade-offs/">accurate</a>.</em> When one test affects another, it becomes difficult to make changes to a single test in isolation. For instance, if a diff makes changes to the some production and test code, and then a test fails, then it is not always clear why the test failed. The failure could due to a bug, or an artifact the coupled tests. Thus, your tests are no longer trustworthy, and therefore, less accurate.</li>
</ol>

<p>Coupling can happen in many ways. The obvious ones include (1) using the same shared dependency (like when you use the same temp file name in all tests), and (2) relying on the post-condition of one test as a precondition of another test. Such cases are also obvious to detect, and to fix. There are two more following ways in which tests can be coupled; but these are more subtle, and more prevalent.</p>

<ol>
  <li>Precondition setting in test fixtures</li>
  <li>Parameterized tests for heterogeneous tests</li>
</ol>

<p>The rest of this note is focused on the above two anti-patterns of test coupling.</p>

<h2 id="coupling-through-test-fixtures">Coupling through test fixtures</h2>

<p>Say, your SUT has a dependency called <code class="language-plaintext highlighter-rouge">Helper</code>, and initially, for the two tests in your unit tests for the SUT, you initialize your <code class="language-plaintext highlighter-rouge">Helper</code> stub with contents <code class="language-plaintext highlighter-rouge">valueA</code>, and <code class="language-plaintext highlighter-rouge">valueB</code>. Since both tests share the same initial state, you include the initialization code in the <code class="language-plaintext highlighter-rouge">SetUp</code> of the unit tests.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">SUTTestCase</span><span class="p">(</span><span class="n">unittest</span><span class="p">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">setUp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">helper</span> <span class="o">=</span> <span class="n">StubHelper</span><span class="p">()</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">helper</span><span class="p">.</span><span class="n">add_contents</span><span class="p">([</span><span class="n">valueA</span><span class="p">,</span> <span class="n">valueB</span><span class="p">])</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">sut</span> <span class="o">=</span> <span class="n">SUT</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">helper</span><span class="p">)</span>
        
    <span class="k">def</span> <span class="nf">test_behavior1</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="p">...</span>  <span class="c1"># Assumes self.helper set with contents=[valueA, valueB]
</span>    
    <span class="k">def</span> <span class="nf">test_behavior2</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="p">...</span>  <span class="c1"># Assumes self.helper set with contents=[valueA, valueB]
</span></code></pre></div></div>

<p>Next, you modify SUT to add features to it. In order to test those features, the <code class="language-plaintext highlighter-rouge">Helper</code> stub needs to include <code class="language-plaintext highlighter-rouge">controllerA</code>. But these are useful only in the new tests being added. However, looking at the unit test you already have, it is easiest to to simply add <code class="language-plaintext highlighter-rouge">controllerA</code> to <code class="language-plaintext highlighter-rouge">self.helper</code>. So, your unit tests look as follows:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">SUTTestCase</span><span class="p">(</span><span class="n">unittest</span><span class="p">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">setUp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">helper</span> <span class="o">=</span> <span class="n">StubHelper</span><span class="p">()</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">helper</span><span class="p">.</span><span class="n">add_contents</span><span class="p">([</span><span class="n">valueA</span><span class="p">,</span> <span class="n">valueB</span><span class="p">])</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">helper</span><span class="p">.</span><span class="n">add_controller</span><span class="p">(</span><span class="n">controllerA</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">sut</span> <span class="o">=</span> <span class="n">SUT</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">helper</span><span class="p">)</span>
        
    <span class="k">def</span> <span class="nf">test_behavior1</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="p">...</span>  <span class="c1"># Assumes self.helper set with contents=[valueA, valueB]
</span>             <span class="c1"># But this test assumes nothing about self.helper's controller
</span>
    <span class="k">def</span> <span class="nf">test_behavior2</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="p">...</span>  <span class="c1"># Assumes self.helper set with contents=[valueA, valueB]
</span>             <span class="c1"># But this test assumes nothing about self.helper's controller
</span>
    <span class="k">def</span> <span class="nf">test_behavior3</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="p">...</span>  <span class="c1"># Assumes self.helper set with contents=[valueA, valueB], and controller=controllerA
</span>
    <span class="k">def</span> <span class="nf">test_behavior4</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="p">...</span>  <span class="c1"># Assumes self.helper set with contents=[valueA, valueB], and controller=controllerA
</span></code></pre></div></div>

<p>Then you discover a gap in testing that requires the initial state of the <code class="language-plaintext highlighter-rouge">Helper</code> stub to have just the content <code class="language-plaintext highlighter-rouge">valueA</code> and include <code class="language-plaintext highlighter-rouge">controllerA</code>. Now, when adding this new unit test to suite, the simplest way to do this would be to remove <code class="language-plaintext highlighter-rouge">valueB</code> from <code class="language-plaintext highlighter-rouge">self.helper</code> at the start of the new test. So, now, your test suite looks as follows:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">SUTTestCase</span><span class="p">(</span><span class="n">unittest</span><span class="p">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">setUp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">helper</span> <span class="o">=</span> <span class="n">StubHelper</span><span class="p">()</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">helper</span><span class="p">.</span><span class="n">add_contents</span><span class="p">([</span><span class="n">valueA</span><span class="p">,</span> <span class="n">valueB</span><span class="p">])</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">helper</span><span class="p">.</span><span class="n">add_controller</span><span class="p">(</span><span class="n">controllerA</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">sut</span> <span class="o">=</span> <span class="n">SUT</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">helper</span><span class="p">)</span>
        
    <span class="k">def</span> <span class="nf">test_behavior1</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="p">...</span>  <span class="c1"># Assumes self.helper set with contents=[valueA, valueB]
</span>             <span class="c1"># But this test assumes nothing about self.helper's controller
</span>
    <span class="k">def</span> <span class="nf">test_behavior2</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="p">...</span>  <span class="c1"># Assumes self.helper set with contents=[valueA, valueB]
</span>             <span class="c1"># But this test assumes nothing about self.helper's controller
</span>
    <span class="k">def</span> <span class="nf">test_behavior3</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="p">...</span>  <span class="c1"># Assumes self.helper set with contents=[valueA, valueB], and controller=controllerA
</span>
    <span class="k">def</span> <span class="nf">test_behavior4</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="p">...</span>  <span class="c1"># Assumes self.helper set with contents=[valueA, valueB], and controller=controllerA
</span>
    <span class="k">def</span> <span class="nf">test_behavior5</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="c1"># Assumes self.helper set with contents=[valueA, valueB] (because of other tests' setup)
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">helper</span><span class="p">.</span><span class="n">remove_content</span><span class="p">(</span><span class="n">valueB</span><span class="p">)</span>
        <span class="c1"># Now assumes self.helper set with contents=[valueA]
</span>        <span class="p">...</span>  
</code></pre></div></div>

<p>Let pause here and inspect the state of the unit test. The tests are coupled. Why? Because modifying one test ends up affecting other tests. In the example above, if we replace <code class="language-plaintext highlighter-rouge">self.helper.add_contents([valueA, valueB])</code> with <code class="language-plaintext highlighter-rouge">self.helper.add_contents(valueA)</code> for tests <code class="language-plaintext highlighter-rouge">test_behavior1</code> and <code class="language-plaintext highlighter-rouge">test_behavior2</code>, it will result in a failure in <code class="language-plaintext highlighter-rouge">test_behavior5</code> because <code class="language-plaintext highlighter-rouge">self.helper.remove_content(valueB)</code> will end up throwing an error!</p>

<p>Furthermore, for anyone reading these tests, it is not entirely clear that <code class="language-plaintext highlighter-rouge">test_behavior1</code>, and <code class="language-plaintext highlighter-rouge">test_behavior2</code> need <code class="language-plaintext highlighter-rouge">self.helper</code> to be initialized with values <code class="language-plaintext highlighter-rouge">[valueA, valueB]</code>, but do not need for <code class="language-plaintext highlighter-rouge">controllerA</code> in <code class="language-plaintext highlighter-rouge">self.helper</code>. The preconditions for <code class="language-plaintext highlighter-rouge">test_behavior1</code> and <code class="language-plaintext highlighter-rouge">test_behavior2</code> are coupled with the preconditions for <code class="language-plaintext highlighter-rouge">test_behavior3</code>.</p>

<p>It also results in test incompleteness in that, if we introduce a bug that causes <code class="language-plaintext highlighter-rouge">behavior1</code> to fail when <code class="language-plaintext highlighter-rouge">self.helper.add_controller(controllerA)</code> is not set, we might not catch that bug because we have initialized the test for <code class="language-plaintext highlighter-rouge">behavior1</code> with <code class="language-plaintext highlighter-rouge">self.helper.add_controller(controllerA)</code>.</p>

<h3 id="how-to-decouple-such-tests">How to decouple such tests?</h3>

<p>Use the <code class="language-plaintext highlighter-rouge">setUp</code> method to simply set up your dependencies, but not to enforce any precondition. Instead, make setting preconditions part of the <em>arrange</em> step of each unit test. You can even encapsulate the precondition setting into a function (with the right parameters) so that the <em>arrange</em> section does not get too bloated, and yet the test code is readable. Consider the following refactoring of the tests:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">SUTTestCase</span><span class="p">(</span><span class="n">unittest</span><span class="p">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">setUp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">helper</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">StubHelper</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">sut</span> <span class="o">=</span> <span class="n">SUT</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">helper</span><span class="p">)</span>
        
    <span class="k">def</span> <span class="nf">prepare_helper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">contents</span><span class="p">:</span><span class="n">List</span><span class="p">[</span><span class="n">Value</span><span class="p">],</span> <span class="n">controller</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Controller</span><span class="p">]</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">helper</span> <span class="o">=</span> <span class="n">StubHelper</span><span class="p">()</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">helper</span><span class="p">.</span><span class="n">add_contents</span><span class="p">(</span><span class="n">contents</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">controller</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">helper</span><span class="p">.</span><span class="n">add_controller</span><span class="p">(</span><span class="n">controller</span><span class="p">)</span>
        
    <span class="k">def</span> <span class="nf">test_behavior1</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="c1"># Assumes self.helper is a fresh object.
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">prepare_helper</span><span class="p">(</span><span class="n">contents</span><span class="o">=</span><span class="p">[</span><span class="n">valueA</span><span class="p">,</span> <span class="n">valueB</span><span class="p">])</span>
        <span class="p">...</span>

    <span class="k">def</span> <span class="nf">test_behavior2</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="c1"># Assumes self.helper is a fresh object.
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">prepare_helper</span><span class="p">(</span><span class="n">contents</span><span class="o">=</span><span class="p">[</span><span class="n">valueA</span><span class="p">,</span> <span class="n">valueB</span><span class="p">])</span>
        <span class="p">...</span>    

    <span class="k">def</span> <span class="nf">test_behavior3</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="c1"># Assumes self.helper is a fresh object.
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">prepare_helper</span><span class="p">(</span><span class="n">contents</span><span class="o">=</span><span class="p">[</span><span class="n">valueA</span><span class="p">,</span> <span class="n">valueB</span><span class="p">],</span> <span class="n">controller</span><span class="o">=</span><span class="n">controllerA</span><span class="p">)</span>
        <span class="p">...</span>

    <span class="k">def</span> <span class="nf">test_behavior4</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="c1"># Assumes self.helper is a fresh object.
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">prepare_helper</span><span class="p">(</span><span class="n">contents</span><span class="o">=</span><span class="p">[</span><span class="n">valueA</span><span class="p">,</span> <span class="n">valueB</span><span class="p">],</span> <span class="n">controller</span><span class="o">=</span><span class="n">controllerA</span><span class="p">)</span>
        <span class="p">...</span>

    <span class="k">def</span> <span class="nf">test_behavior5</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="c1"># Assumes self.helper is a fresh object.
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">prepare_helper</span><span class="p">(</span><span class="n">contents</span><span class="o">=</span><span class="p">[</span><span class="n">valueA</span><span class="p">],</span> <span class="n">controller</span><span class="o">=</span><span class="n">controllerA</span><span class="p">)</span>
        <span class="p">...</span>
</code></pre></div></div>

<h2 id="coupling-in-parameterized-tests">Coupling in parameterized tests</h2>

<p><a href="https://dl.acm.org/doi/10.1145/1095430.1081749">Parameterized tests</a> are a collection of tests that run the same verification, but with different inputs. While this is a very useful feature (available in almost all unit test frameworks), it is also very easy to abuse. A few common ways I have seen it abused is in conjunction with <a href="https://srikanth.sastry.name/dry-unit-tests-are-bad/">DRYing</a>, and the use ‘if’ checks, and that often results in coupling all the tests denoted by the parameterized list. Consider the following illustration:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">TestOutput</span><span class="p">(</span><span class="n">typing</span><span class="p">.</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="n">status</span><span class="p">:</span> <span class="n">StatusEnum</span>
    <span class="n">return_value</span><span class="p">:</span> <span class="n">typing</span><span class="p">.</span><span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
    <span class="n">exception</span><span class="p">:</span> <span class="n">typing</span><span class="p">.</span><span class="n">Optional</span><span class="p">[</span><span class="nb">Exception</span><span class="p">]</span>
    <span class="p">...</span>

<span class="k">class</span> <span class="nc">TestSequence</span><span class="p">(</span><span class="n">unittest</span><span class="p">.</span><span class="n">TestCase</span><span class="p">):</span>
  
    <span class="o">@</span><span class="n">parameterized</span><span class="p">.</span><span class="n">expand</span><span class="p">([</span>
        <span class="p">[</span><span class="n">test_input1</span><span class="p">,</span> <span class="n">expected_output1</span><span class="p">],</span>
        <span class="p">[</span><span class="n">test_input2</span><span class="p">,</span> <span class="n">expected_output2</span><span class="p">],</span>
        <span class="p">...</span>
    <span class="p">])</span>
    <span class="k">def</span> <span class="nf">test_something</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">test_input</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">expected_output</span><span class="p">:</span> <span class="n">TestOutput</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">_run_test</span><span class="p">(</span><span class="n">test_input</span><span class="p">,</span> <span class="n">expected_output</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">_run_test</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">test_input</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">expected_output</span><span class="p">:</span> <span class="n">TestOutput</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">sut</span> <span class="o">=</span> <span class="n">SUT</span><span class="p">(...)</span>
        <span class="n">prepare_sut_for_tests</span><span class="p">(</span><span class="n">sut</span><span class="p">,</span> <span class="n">test_input</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">sut</span><span class="p">.</span><span class="n">do_something</span><span class="p">(</span><span class="n">test_input</span><span class="p">)</span>
        <span class="n">test_output</span> <span class="o">=</span> <span class="n">make_test_output</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">sut</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">assertEquals</span><span class="p">(</span><span class="n">expected_output</span><span class="p">,</span> <span class="n">test_output</span><span class="p">)</span>

</code></pre></div></div>

<p>The above illustration tests the method <code class="language-plaintext highlighter-rouge">do_something</code> for various possible inputs. However, note that the outputs (as illustrated in the class <code class="language-plaintext highlighter-rouge">TestOutput</code> can have a <code class="language-plaintext highlighter-rouge">status</code>, a <code class="language-plaintext highlighter-rouge">return_value</code>, or an <code class="language-plaintext highlighter-rouge">exception</code>). This means that every instantiation (for each parameter) has to content with the possibility of different types of outputs even though any single test only should have to verify against a single type of output. This couples all the tests verifying <code class="language-plaintext highlighter-rouge">do_something</code>, this making it difficult to read and understand. Adding a new test case here becomes tricky because any changes to either <code class="language-plaintext highlighter-rouge">prepare_sut_for_tests</code>, or <code class="language-plaintext highlighter-rouge">make_test_output</code> now affects all the tests!</p>

<h3 id="how-to-decouple-parameterized-tests">How to decouple parameterized tests?</h3>

<p>There are some fairly straightforward ways to decouple such tests. First, is that we should be very conservative about how we organize these tests. For example, we can group all positive tests and group all negative tests separately; similarly, we can further subgroup the tests based on the type of assertions on the output. In the above example, we can have three subgroups: positive tests that verify only output status, positive tests that verify return value, and negative tests that verify exception. Thus you now have three parameterized test classes that look something like this:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">TestDoSomething</span><span class="p">(</span><span class="n">unittest</span><span class="p">.</span><span class="n">TestCase</span><span class="p">):</span>
  
    <span class="o">@</span><span class="n">parameterized</span><span class="p">.</span><span class="n">expand</span><span class="p">([</span>
        <span class="p">[</span><span class="n">test_status_input1</span><span class="p">,</span> <span class="n">expected_status_output1</span><span class="p">],</span>
        <span class="p">[</span><span class="n">test_status_input2</span><span class="p">,</span> <span class="n">expected_status_output2</span><span class="p">],</span>
        <span class="p">...</span>
    <span class="p">])</span>
    <span class="k">def</span> <span class="nf">test_something_status_only</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> 
        <span class="n">test_input</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> 
        <span class="n">expected_output</span><span class="p">:</span> <span class="n">StatusEnum</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="c1"># Arrange
</span>        <span class="n">sut</span> <span class="o">=</span> <span class="n">SUT</span><span class="p">(...)</span>
        <span class="p">...</span>  <span class="c1"># More 'arrange' code
</span>        
        <span class="c1"># Act
</span>        <span class="n">output</span> <span class="o">=</span> <span class="n">sut</span><span class="p">.</span><span class="n">do_something</span><span class="p">(</span><span class="n">test_input</span><span class="p">)</span>
        <span class="n">output_status</span> <span class="o">=</span> <span class="n">output</span><span class="p">.</span><span class="n">status</span>
        
        <span class="c1"># Assert
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">assertEquals</span><span class="p">(</span><span class="n">expected_output</span><span class="p">,</span> <span class="n">output_status</span><span class="p">)</span>
        
    <span class="o">@</span><span class="n">parameterized</span><span class="p">.</span><span class="n">expand</span><span class="p">([</span>
        <span class="p">[</span><span class="n">test_return_value_input1</span><span class="p">,</span> <span class="n">expected_return_value_output1</span><span class="p">],</span>
        <span class="p">[</span><span class="n">test_return_value_input2</span><span class="p">,</span> <span class="n">expected_return_value_output2</span><span class="p">],</span>
        <span class="p">...</span>
    <span class="p">])</span>
    <span class="k">def</span> <span class="nf">test_something_return_value_only</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> 
        <span class="n">test_input</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> 
        <span class="n">expected_output</span><span class="p">:</span> <span class="nb">int</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="c1"># Arrange
</span>        <span class="n">sut</span> <span class="o">=</span> <span class="n">SUT</span><span class="p">(...)</span>
        <span class="p">...</span>  <span class="c1"># More 'arrange' code
</span>        
        <span class="c1"># Act
</span>        <span class="n">output</span> <span class="o">=</span> <span class="n">sut</span><span class="p">.</span><span class="n">do_something</span><span class="p">(</span><span class="n">test_input</span><span class="p">)</span>
        <span class="n">output_status</span> <span class="o">=</span> <span class="n">output</span><span class="p">.</span><span class="n">status</span>
        <span class="n">output_value</span> <span class="o">=</span> <span class="n">output</span><span class="p">.</span><span class="n">value</span>
        
        <span class="c1"># Assert
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">assertEquals</span><span class="p">(</span><span class="n">SomeEnum</span><span class="p">.</span><span class="n">SUCCESS</span><span class="p">,</span> <span class="n">output_status</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">assertEquals</span><span class="p">(</span><span class="n">expected_output</span><span class="p">,</span> <span class="n">output_value</span><span class="p">)</span>

    <span class="o">@</span><span class="n">parameterized</span><span class="p">.</span><span class="n">expand</span><span class="p">([</span>
        <span class="p">[</span><span class="n">test_return_value_input1</span><span class="p">,</span> <span class="n">expected_error_code_output1</span><span class="p">],</span>
        <span class="p">[</span><span class="n">test_return_value_input2</span><span class="p">,</span> <span class="n">expected_error_code_output2</span><span class="p">],</span>
        <span class="p">...</span>
    <span class="p">])</span>
    <span class="k">def</span> <span class="nf">test_something_throws_exception</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">test_input</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">expected_error_code</span><span class="p">:</span> <span class="nb">int</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="c1"># Arrange
</span>        <span class="n">sut</span> <span class="o">=</span> <span class="n">SUT</span><span class="p">(...)</span>
        <span class="p">...</span>  <span class="c1"># More 'arrange' code
</span>        
        <span class="c1"># Act
</span>        <span class="k">with</span> <span class="bp">self</span><span class="p">.</span><span class="n">assertRaises</span><span class="p">(</span><span class="n">SomeSUTException</span><span class="p">)</span> <span class="k">as</span> <span class="n">exception_context</span><span class="p">:</span>
            <span class="n">sut</span><span class="p">.</span><span class="n">do_something</span><span class="p">(</span><span class="n">test_input</span><span class="p">)</span>
        <span class="n">exception</span> <span class="o">=</span> <span class="n">exception_context</span><span class="p">.</span><span class="n">exception</span>
        
        <span class="c1"># Assert
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">assertEquals</span><span class="p">(</span><span class="n">excepted_error_code</span><span class="p">,</span> <span class="n">exception</span><span class="p">.</span><span class="n">error_code</span><span class="p">)</span>
</code></pre></div></div>

</div>




      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

    <script src='/public/js/script.js'></script>
  </body>
</html>
